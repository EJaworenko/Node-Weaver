{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Node Weaver","text":"<p>Node Weaver is a comprehensive toolset for Houdini Technical Directors that streamlines tool creation and customization workflows. Whether you're building HDAs, managing node networks, or customizing the Houdini interface, Node Weaver provides utilities to make your work more efficient.</p>"},{"location":"#documentation-quick-links","title":"Documentation Quick Links","text":""},{"location":"#core-documentation","title":"Core Documentation","text":"<ul> <li>Installation Guide</li> <li>Git Guide for Beginners</li> <li>Troubleshooting</li> <li>Contributing Guide</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Tool Maker Tools - HDA development utilities</li> <li>Node Shape Creator - Custom node shape design</li> <li>Color Palette Configurator - Network color customization</li> </ul>"},{"location":"#features_1","title":"Features","text":""},{"location":"#tool-development-suite","title":"Tool Development Suite","text":"<ul> <li>Tool Maker HDA: Automate common TD tasks including:</li> <li>Menu script generation</li> <li>Copy-to-points to instancing conversion</li> <li>Mass parameter connections</li> <li>Learn more \u2192</li> </ul>"},{"location":"#customization-tools","title":"Customization Tools","text":"<ul> <li>Node Shape Creator: Design custom node shapes with real-time preview</li> <li>Shape editing and visualization tools</li> <li>Export directly to Houdini format</li> <li>Integration with existing node networks</li> <li> <p>Learn more \u2192</p> </li> <li> <p>Color Palette Configurator: Enhance your node network organization</p> </li> <li>Modify default color palette</li> <li>Create custom gradients</li> <li>Import/export color schemes</li> <li>Learn more \u2192</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Houdini 19.5 or later</li> <li>Python 3.7+</li> <li>Git (optional, only needed if you want automatic updates)</li> </ul>"},{"location":"#installation-options","title":"Installation Options","text":""},{"location":"#simple-download-recommended-for-beginners","title":"Simple Download (Recommended for Beginners)","text":"<ol> <li>Download the latest release</li> <li>Follow my simple installation guide</li> </ol>"},{"location":"#git-installation-for-automatic-updates","title":"Git Installation (For Automatic Updates)","text":"<p><pre><code>git clone https://github.com/EJaworenko/Node-Weaver.git\n</code></pre> Then follow my Git-based installation guide</p>"},{"location":"#new-to-git","title":"New to Git?","text":"<p>Don't worry! I've created a beginner-friendly Git guide that explains: - What Git is and why it's useful - How to install Git on your system - Basic Git commands you might need - How to get updates using Git</p> <p>If you're not comfortable with Git yet, use the Simple Download method instead.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Detailed setup instructions</li> <li>Git Guide for Beginners - Version control basics explained simply</li> <li>Feature Documentation - In-depth guides for each tool</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>The project is small, but I welcome contributions of any kind! If you're new to open source check out: 1. My Git Guide for version control basics 2. GitHub's guide on Creating a Pull Request 3. The issues page for beginner-friendly tasks</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue for bugs or feature requests</li> <li>Check troubleshooting for common issues</li> <li>Review existing issues before creating new ones</li> <li>Don't hesitate to ask questions - I'm here to help!</li> </ul>"},{"location":"#license","title":"License","text":"<p>Node Weaver is licensed under the GNU General Public License v3.0. See LICENSE for details.</p>"},{"location":"contributing/","title":"Contributing to Node Weaver","text":"<p>\u2190 Back to main documentation</p> <p>Thank you for your interest in making Node Weaver better! As a solo developer, I greatly appreciate any help in identifying issues, suggesting improvements, and sharing how you use the tools.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#1-report-bugs","title":"1. Report Bugs \ud83d\udc1b","text":"<p>Found something that's not working right? Let me know! Here's how to submit a helpful bug report:</p>"},{"location":"contributing/#what-makes-a-good-bug-report","title":"What Makes a Good Bug Report:","text":"<ul> <li>A clear title describing the issue</li> <li>Steps to reproduce the problem</li> <li>What you expected to happen</li> <li>What actually happened</li> <li>Your Houdini version</li> <li>Screenshots if relevant</li> </ul>"},{"location":"contributing/#example-bug-report","title":"Example Bug Report:","text":"<pre><code>Title: Color Palette Configurator crashes when importing hex values\n\nDescription:\n1. Opened Color Palette Configurator\n2. Clicked Import\n3. Pasted hex value #FF5733\n4. Clicked OK\n5. Tool crashed\n\nExpected: Hex color should be imported\nActual: Tool crashes completely\n\nHoudini Version: 20.5.435\n</code></pre>"},{"location":"contributing/#2-suggest-features","title":"2. Suggest Features \ud83d\udca1","text":"<p>Have an idea for improving Node Weaver? I'd love to hear it! When suggesting features:</p> <ul> <li>Explain the problem you're trying to solve</li> <li>Describe how you think it should work</li> <li>Share examples if you have them</li> <li>Let me know how urgent this would be for your workflow</li> </ul>"},{"location":"contributing/#3-share-your-use-cases","title":"3. Share Your Use Cases \ud83c\udfa8","text":"<p>Knowing how people use Node Weaver helps me make it better: - Share screenshots of your setups - Tell me about your workflows - Suggest documentation improvements based on your experience - Share tips and tricks you've discovered</p>"},{"location":"contributing/#4-ask-questions","title":"4. Ask Questions \u2753","text":"<p>Questions help improve the documentation and identify unclear areas: - No question is too basic - Others probably have the same question - Helps me understand what needs better documentation</p>"},{"location":"contributing/#5-help-others","title":"5. Help Others \ud83e\udd1d","text":"<ul> <li>Answer questions in GitHub Issues</li> <li>Share your solutions to problems</li> <li>Suggest workarounds you've found</li> </ul>"},{"location":"contributing/#how-to-submit-contributions","title":"How to Submit Contributions","text":""},{"location":"contributing/#for-bug-reports-and-feature-requests","title":"For Bug Reports and Feature Requests:","text":"<ol> <li>Go to Issues</li> <li>Click \"New Issue\"</li> <li>Choose the appropriate template</li> <li>Fill in the details</li> <li>Submit!</li> </ol>"},{"location":"contributing/#for-questions-and-discussion","title":"For Questions and Discussion:","text":"<ol> <li>Go to Discussions</li> <li>Choose the appropriate category</li> <li>Share your thoughts!</li> </ol>"},{"location":"contributing/#development-contributions","title":"Development Contributions","text":"<p>While Node Weaver is primarily a solo project, I'm open to code contributions if you're interested. Please reach out via GitHub Issues first to discuss any code changes you'd like to make.</p>"},{"location":"contributing/#conduct-guidelines","title":"Conduct Guidelines","text":"<ul> <li>Be respectful and constructive</li> <li>Provide as much detail as possible</li> <li>Be patient - I'm a solo developer and might not respond immediately</li> <li>Help others when you can</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors will be thanked in: - Release notes - Documentation - The project README</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Not sure about something? Feel free to: - Open a Discussion - Create an Issue - Ask for clarification</p> <p>Remember: Every contribution helps make Node Weaver better for everyone. Thank you for being part of this project! \ud83d\ude4f</p>"},{"location":"git-guide/","title":"Git Guide","text":""},{"location":"git-guide/#git-guide-for-beginners","title":"Git Guide for Beginners","text":"<p>\u2190 Back to main documentation</p> <p>I've provided this guide because as someone who came out of arts, I remember struggling with Github projects and how to use them in my own work. I hope it helps.</p>"},{"location":"git-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What is Git?</li> <li>Git vs. GitHub: What's the Difference?</li> <li>Why is Node Weaver on Github?</li> <li>Installing Git</li> <li>Windows</li> <li>Mac</li> <li>Linux (Ubuntu/Debian)</li> <li>Common Git Tasks</li> <li>Getting Node Weaver for the First Time</li> <li>Updating Node Weaver</li> <li>What If You Made Changes?</li> <li>Visual Git Tools</li> <li>Troubleshooting</li> <li>\"Git isn't recognized as a command\"</li> <li>\"Permission denied\" Errors</li> <li>\"Refusing to merge unrelated histories\"</li> <li>Changes Not Downloading</li> <li>Still Stuck?</li> </ul>"},{"location":"git-guide/#what-is-git","title":"What is Git?","text":"<p>Git is like a very powerful \"Save As\" for your projects. It: - Keeps track of all changes you make - Lets you go back to any previous version - Helps you get updates without losing your changes - Makes it easy to share improvements with others</p>"},{"location":"git-guide/#git-vs-github-whats-the-difference","title":"Git vs. GitHub: What's the Difference?","text":"<ul> <li>Git is the tool that tracks changes on your computer</li> <li>GitHub is the website where people share their Git projects</li> <li>In other words:</li> <li>Git = The tool you write with</li> <li>GitHub = The library where you share your writing</li> </ul>"},{"location":"git-guide/#why-is-node-weaver-on-github","title":"Why is Node Weaver on Github?","text":"<p>Downloading Node Weaver using Git gives you several benefits: 1. Easy Updates: Get new features and fixes with a single command 2. Safe Customization: Make your own changes without breaking updates 3. Contribution: Share your improvements if you want to 4. History: Track changes you make to your tools</p>"},{"location":"git-guide/#installing-git","title":"Installing Git","text":""},{"location":"git-guide/#windows","title":"Windows","text":"<ol> <li>Download Git from git-scm.com</li> <li>Run the installer</li> <li>Use these recommended settings:</li> <li>When asked about line ending conversions, choose \"Checkout as-is, commit as-is\"</li> <li>For the default editor, choose \"Visual Studio Code\" if you have it, or \"Notepad\" if not</li> <li>For everything else, the defaults are fine</li> </ol>"},{"location":"git-guide/#mac","title":"Mac","text":"<ol> <li>Open Terminal</li> <li>Type <code>git --version</code></li> <li>If Git isn't installed, macOS will prompt you to install it</li> </ol>"},{"location":"git-guide/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt-get update\nsudo apt-get install git\n</code></pre>"},{"location":"git-guide/#common-git-tasks","title":"Common Git Tasks","text":""},{"location":"git-guide/#getting-node-weaver-for-the-first-time","title":"Getting Node Weaver for the First Time","text":"<pre><code># 1. Open Terminal (Mac/Linux) or Git Bash (Windows)\n# 2. Go to where you want to install. For example, the Documents folder\ncd Documents\n\n# 3. Get Node Weaver\ngit clone https://github.com/EJaworenko/Node-Weaver.git\n</code></pre>"},{"location":"git-guide/#updating-node-weaver","title":"Updating Node Weaver","text":"<pre><code># 1. Open Terminal/Git Bash in your Node Weaver folder\n# 2. Get updates\ngit pull origin main\n</code></pre>"},{"location":"git-guide/#what-if-you-made-changes","title":"What If You Made Changes?","text":"<p>If you've modified any Node Weaver files and try to update, Git will warn you. Here's what to do:</p> <ol> <li> <p>If you want to keep your changes:    <pre><code># Save your changes temporarily\ngit stash\n\n# Get updates\ngit pull origin main\n\n# Bring your changes back\ngit stash pop\n</code></pre></p> </li> <li> <p>If you want to discard your changes:    <pre><code># Reset everything to original state\ngit reset --hard\n\n# Get updates\ngit pull origin main\n</code></pre></p> </li> </ol>"},{"location":"git-guide/#visual-git-tools","title":"Visual Git Tools","text":"<p>If you prefer using a visual interface instead of commands, try these free tools: - GitHub Desktop - Simplest option, works with GitHub - Sourcetree - More powerful, but more complex - Visual Studio Code - Good if you also write code</p>"},{"location":"git-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"git-guide/#git-isnt-recognized-as-a-command","title":"\"Git isn't recognized as a command\"","text":"<ul> <li>Windows: Reinstall Git and make sure to select \"Add to PATH\" during installation</li> <li>Mac/Linux: Make sure Git is installed by running <code>git --version</code></li> </ul>"},{"location":"git-guide/#permission-denied-errors","title":"\"Permission denied\" Errors","text":"<ul> <li>Make sure you're not in a protected folder (like Program Files on Windows)</li> <li>Try running your terminal/Git Bash as administrator</li> </ul>"},{"location":"git-guide/#refusing-to-merge-unrelated-histories","title":"\"Refusing to merge unrelated histories\"","text":"<pre><code># Use this command instead of regular pull\ngit pull origin main --allow-unrelated-histories\n</code></pre>"},{"location":"git-guide/#changes-not-downloading","title":"Changes Not Downloading","text":"<ol> <li>Make sure you're connected to the internet</li> <li>Try forcing an update:    <pre><code>git fetch --all\ngit reset --hard origin/main\n</code></pre></li> </ol>"},{"location":"git-guide/#still-stuck","title":"Still Stuck?","text":"<ol> <li>Check if others had the same issue in the Issues section</li> <li>If not, feel free to open a new issue</li> <li>Include:</li> <li>What you were trying to do</li> <li>The exact error message</li> <li>What you've tried so far</li> </ol> <p>Remember: Everyone was a beginner once. Don't be afraid to ask for help!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation-guide","title":"Installation Guide","text":"<p>\u2190 Back to main documentation</p> <p>This guide walks you through installing Node Weaver in Houdini. Choose the installation method that works best for you.</p>"},{"location":"installation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Prerequisites</li> <li>Method 1: Simple Installation</li> <li>Step 1: Download Node Weaver</li> <li>Step 2: Extract Files</li> <li>Step 3: Set Up the Package</li> <li>Step 4:Start Houdini</li> <li>Method 2: Git Installation</li> <li>Verifying Installation</li> <li>Common Installation Paths</li> <li>Windows</li> <li>Mac</li> <li>Linux</li> <li>Troubleshooting</li> <li>Can't Find Preferences Folder?</li> <li>Tools Not Showing Up?</li> <li>Permission Issues?</li> <li>Need More Help?</li> </ul>"},{"location":"installation/#quick-start","title":"Quick Start","text":"<ol> <li>Download Node Weaver</li> <li>Put it somewhere on your computer (a dedicated Houdini tools folder ideally)</li> <li>Add it as a Houdini package</li> <li>Start Houdini and check that it installed</li> </ol> <p>Need more detail? Read on!</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Houdini 19.5 or later</li> <li>Python 3.7+</li> <li>Admin rights on your computer (for some installation locations)</li> <li>Git (optional, only for Method 2)</li> </ul>"},{"location":"installation/#method-1-simple-installation","title":"Method 1: Simple Installation","text":""},{"location":"installation/#step-1-download-node-weaver","title":"Step 1: Download Node Weaver","text":"<ol> <li>Visit the releases page</li> <li>Find the latest release</li> <li>Click \"Source code (zip)\" under Assets</li> <li>Save the zip file anywhere</li> </ol>"},{"location":"installation/#step-2-extract-files","title":"Step 2: Extract Files","text":"<ol> <li>Find a good location for Node Weaver:</li> <li>\u2705 A dedicated Houdini tools folder. Set one up if you don't have one for your own sanity</li> <li>\u274c NOT in Houdini's program files</li> <li> <p>\u274c NOT in your Houdini preferences folder</p> </li> <li> <p>Example good locations:</p> </li> <li>Windows: <code>C:/Users/YourUsername/Documents/HoudiniTools/NodeWeaver</code></li> <li>Mac: <code>/Users/YourUsername/Documents/HoudiniTools/NodeWeaver</code></li> <li> <p>Linux: <code>/home/YourUsername/HoudiniTools/NodeWeaver</code></p> </li> <li> <p>Extract the zip file there</p> </li> </ol>"},{"location":"installation/#step-3-set-up-the-package","title":"Step 3: Set Up the Package","text":"<ol> <li>Find your Houdini preferences folder:</li> <li>Windows: <code>C:/Users/YourUsername/Documents/houdiniXX.X</code></li> <li>Mac: <code>~/Library/Preferences/houdini/XX.X</code></li> <li> <p>Linux: <code>/home/YourUsername/houdini/XX.X</code>    Replace XX.X with your Houdini version (like 20.5)</p> </li> <li> <p>In your preferences folder:</p> </li> <li>Look for a \"packages\" folder</li> <li> <p>If it doesn't exist, create it</p> </li> <li> <p>Copy the Package File:</p> </li> <li>Find <code>nodeweaver.json</code> in your Node Weaver folder</li> <li> <p>Copy it to the packages folder</p> </li> <li> <p>Edit the Package File:</p> </li> <li>Open <code>nodeweaver.json</code> in any text editor</li> <li>Find the line with <code>\"NODEWEAVER\":</code></li> <li>Change the path to where you put Node Weaver</li> </ol> <p>Example <code>nodeweaver.json</code>: <pre><code>    \"env\": [\n        {\n            \"NODEWEAVER\": \"C:/Path/To/Nodeweaver/Installation/NodeWeaver\"\n        }\n    ]\n</code></pre></p>"},{"location":"installation/#step-4start-houdini","title":"Step 4:Start Houdini","text":"<ul> <li>Close Houdini completely (if it was open)</li> <li>Start Houdini</li> </ul>"},{"location":"installation/#method-2-git-installation","title":"Method 2: Git Installation","text":"<p>This method makes updating easier but requires Git. New to Git? Check my Git Guide.</p> <ol> <li>Open Terminal/Git Bash</li> <li>Navigate to where you want Node Weaver:    <pre><code>cd C:/Path/To/Nodeweaver/Installation/NodeWeaver\n</code></pre></li> <li>Clone the repository:    <pre><code>git clone https://github.com/EJaworenko/Node-Weaver.git\n</code></pre></li> <li>Follow Steps 3-4 from Method 1 above</li> </ol>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<ol> <li>Start Houdini</li> <li>Press Tab in a network view  (OBJ or SOP context)</li> <li>Look for \"Node Weaver Toolkit\" in the categories</li> <li>Try creating a tool from the tab menu</li> </ol> <p>If you don't see the tools: 1. Try restarting Houdini 2. Check your package path 3. See Troubleshooting</p>"},{"location":"installation/#common-installation-paths","title":"Common Installation Paths","text":""},{"location":"installation/#windows","title":"Windows","text":"<pre><code>Node Weaver Location:\nC:/Users/YourUsername/Documents/HoudiniTools/NodeWeaver\n\nPackage File:\nC:/Users/YourUsername/Documents/houdini19.5/packages/nodeweaver.json\n</code></pre>"},{"location":"installation/#mac","title":"Mac","text":"<pre><code>Node Weaver Location:\n/Users/YourUsername/Documents/HoudiniTools/NodeWeaver\n\nPackage File:\n~/Library/Preferences/houdini/19.5/packages/nodeweaver.json\n</code></pre>"},{"location":"installation/#linux","title":"Linux","text":"<pre><code>Node Weaver Location:\n/home/YourUsername/HoudiniTools/NodeWeaver\n\nPackage File:\n/home/YourUsername/houdini19.5/packages/nodeweaver.json\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#cant-find-preferences-folder","title":"Can't Find Preferences Folder?","text":"<p>In Houdini: 1. Go to File \u2192 Open 2. Type $HOUDINI_USER_PREF_DIR in the address bar at the top and press enter. 3. Right click the address and press \"Expand Path\" 4. That's your preferences folder!</p>"},{"location":"installation/#tools-not-showing-up","title":"Tools Not Showing Up?","text":"<ol> <li>Check your <code>nodeweaver.json</code>:</li> <li>Path should match your Node Weaver location exactly</li> <li>Use forward slashes (/) even on Windows</li> <li>Spaces in the path may cause problems, ideally use _ or - instead.</li> <li>Make sure the packages folder exists</li> <li>Restart Houdini</li> </ol>"},{"location":"installation/#permission-issues","title":"Permission Issues?","text":"<ul> <li>Don't install in Program Files</li> <li>Try running Houdini as administrator</li> <li>Check folder permissions</li> </ul>"},{"location":"installation/#need-more-help","title":"Need More Help?","text":"<ul> <li>See the Troubleshooting Guide</li> <li>Open an issue</li> <li>Check existing issues for solutions</li> </ul> <p>Remember: If something's not working, don't hesitate to ask for help!</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<p>\u2190 Back to main documentation</p> <p>This guide covers common issues you might encounter while using Node Weaver and how to solve them.</p>"},{"location":"troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation Issues</li> <li>Tools Not Showing Up in Houdini<ul> <li>Check Your Package Path</li> <li>Can't Find Houdini Preferences Folder?</li> </ul> </li> <li>Package Installation Issues<ul> <li>Missing Packages Folder</li> <li>Wrong Houdini Version</li> </ul> </li> <li>Update Issues</li> <li>Manual Download Updates</li> <li>Git Update Issues<ul> <li>Changes Won't Download</li> <li>Local Changes Blocking Update</li> </ul> </li> <li>Common Tool Issues</li> <li>Getting Help</li> <li>Before Asking for Help</li> <li>How to Report an Issue</li> <li>Getting Quick Help</li> </ul>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#tools-not-showing-up-in-houdini","title":"Tools Not Showing Up in Houdini","text":""},{"location":"troubleshooting/#check-your-package-path","title":"Check Your Package Path","text":"<ol> <li>Find your <code>nodeweaver.json</code> file in your Houdini preferences folder:</li> <li>Windows: <code>C:/Users/YourUsername/Documents/houdiniXX.X/packages/</code></li> <li>Mac: <code>~/Library/Preferences/houdini/XX.X/packages/</code></li> <li> <p>Linux: <code>/home/YourUsername/houdini/XX.X/packages/</code></p> </li> <li> <p>Open <code>nodeweaver.json</code> and verify:</p> </li> <li>The path matches where you installed Node Weaver</li> <li>There are no extra spaces in the path</li> <li>Use forward slashes (/) even on Windows</li> </ol> <p>Example of correct path (If you extracted the NodeWeaver folder there): <pre><code>{\n    \"env\": [\n        {\n            \"NODEWEAVER\": \"C:/Users/YourName/Documents/NodeWeaver\"\n        }\n    ]\n}\n</code></pre></p>"},{"location":"troubleshooting/#cant-find-houdini-preferences-folder","title":"Can't Find Houdini Preferences Folder?","text":"<ol> <li>Open Houdini</li> <li>Go to File \u2192 Open</li> <li>Type <code>$HOUDINI_USER_PREF_DIR</code> in the address bar</li> <li>Press Enter</li> <li>The window now shows your preferences folder</li> <li>Right click the address bar and click \"Expand Path\" and it will show you the actual location</li> </ol>"},{"location":"troubleshooting/#package-installation-issues","title":"Package Installation Issues","text":""},{"location":"troubleshooting/#missing-packages-folder","title":"Missing Packages Folder","text":"<ol> <li>Go to your Houdini preferences folder</li> <li>Create a new folder called \"packages\"</li> <li>Copy <code>nodeweaver.json</code> into it</li> <li>Restart Houdini</li> </ol>"},{"location":"troubleshooting/#wrong-houdini-version","title":"Wrong Houdini Version","text":"<ul> <li>Node Weaver requires Houdini 19.5 or later, which is a bit older at this point.</li> <li>Check your Houdini version: Help \u2192 About Houdini</li> </ul>"},{"location":"troubleshooting/#update-issues","title":"Update Issues","text":""},{"location":"troubleshooting/#manual-download-updates","title":"Manual Download Updates","text":"<p>If you downloaded Node Weaver manually: 1. Download the new version 2. Replace old Node Weaver folder with new version 3. Your <code>nodeweaver.json</code> shouldn't need to update, but compare the old file to the new one.    If everything looks the same except the path, you're fine. 4. Restart Houdini</p>"},{"location":"troubleshooting/#git-update-issues","title":"Git Update Issues","text":""},{"location":"troubleshooting/#changes-wont-download","title":"Changes Won't Download","text":"<pre><code># Force update (will overwrite local changes)\ngit fetch --all\ngit reset --hard origin/main\n</code></pre>"},{"location":"troubleshooting/#local-changes-blocking-update","title":"Local Changes Blocking Update","text":"<p>If you've modified Node Weaver files: <pre><code># Save your changes\ngit stash\n\n# Get updates\ngit pull origin main\n\n# Restore your changes\ngit stash pop\n</code></pre></p>"},{"location":"troubleshooting/#common-tool-issues","title":"Common Tool Issues","text":"<p>As problems in the tools appear, I'll document them here.</p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#before-asking-for-help","title":"Before Asking for Help","text":"<ol> <li>Check if your issue is listed in this guide</li> <li>Search existing GitHub issues</li> <li>Try the solutions mentioned above</li> <li>Collect relevant error messages</li> </ol>"},{"location":"troubleshooting/#how-to-report-an-issue","title":"How to Report an Issue","text":"<ol> <li>Go to the Issues page</li> <li>Click \"New Issue\"</li> <li>Include:</li> <li>What you were trying to do</li> <li>What happened instead</li> <li>Steps to reproduce the issue</li> <li>Your Houdini version</li> <li>Error messages (if any)</li> <li>Screenshots (if relevant)</li> </ol>"},{"location":"troubleshooting/#getting-quick-help","title":"Getting Quick Help","text":"<ul> <li>Join Node Weaver GitHub discussions</li> <li>Check existing issues for solutions</li> <li>Include as much detail as possible in new issues</li> </ul> <p>Remember: The more information you provide about your issue, the faster I can help you solve it!</p>"},{"location":"features/","title":"Node Weaver Features","text":"<p>\u2190 Back to main documentation</p> <p>I've created Node Weaver to streamline common Houdini TD tasks and make network customization easier. Here's what each tool does and how to get started with them.</p>"},{"location":"features/#available-tools","title":"Available Tools","text":""},{"location":"features/#tool-maker-tools","title":"Tool Maker Tools","text":"<p>Documentation \u2192</p> <p>The Tool Maker Tools came from my own needs as a TD, automating repetitive tasks like: - Generating menu and action button scripts - Converting copy-to-points setups to instancing - Mass-connecting parameters between nodes - Finding and replacing node names</p> <p>I've included several shelf tools and right-click menu additions to make these features easily accessible.</p>"},{"location":"features/#node-shape-creator","title":"Node Shape Creator","text":"<p>Documentation \u2192</p> <p>After seeing the work by Simon Fiedler and Bastian Schiffer on custom node shapes, I wanted to make the process more accessible. This tool lets you: - Design custom node shapes with real-time preview - Export directly to Houdini's format - Analyze existing node shapes - Test shapes with different wire configurations</p>"},{"location":"features/#color-palette-configurator","title":"Color Palette Configurator","text":"<p>Documentation \u2192</p> <p>Getting tired of the default node colors, I built this to make network organization more flexible. You can: - Modify the default color palette - Create custom gradients - Import colors from hex codes - Save and share color schemes</p>"},{"location":"features/#getting-started","title":"Getting Started","text":"<p>Each tool has its own documentation page with: - Detailed usage instructions - Examples and screenshots - Tips and tricks - Common issues and solutions</p>"},{"location":"features/#need-help","title":"Need Help?","text":"<p>If you run into any issues or have questions: 1. Check the individual tool documentation 2. Look at the troubleshooting guide 3. Open an issue if you're still stuck</p> <p>I appreciate all feedback and bug reports - they help make these tools better!</p>"},{"location":"features/color-palette/","title":"Color Palette","text":""},{"location":"features/color-palette/#color-palette-configurator-hda","title":"Color Palette Configurator HDA","text":"<p>\u2190 Back to features</p> <p>The Color Palette Configurator makes it easy to customize Houdini's node colors. I created this tool to make network organization more flexible and visually appealing.</p>"},{"location":"features/color-palette/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Getting Started</li> <li>Features</li> <li>Main Color List</li> <li>Gradient Generator<ul> <li>Step 1: Creating Gradients</li> <li>Example Cosine Parameter Effects</li> <li>Built-in Presets</li> <li>Step 2: Using Gradient Samples</li> </ul> </li> <li>Text-Based Colors</li> <li>Exporting Colors<ul> <li>Sharing Palettes</li> </ul> </li> <li>Troubleshooting</li> <li>Colors Not Updating</li> <li>Colors Look Different</li> <li>Need Help?</li> </ul>"},{"location":"features/color-palette/#overview","title":"Overview","text":"<p>By default, Houdini gives you 36 colors in the network palette. This tool lets you: - Modify these colors - Create new color schemes - Generate color gradients - Import and export palettes</p>"},{"location":"features/color-palette/#getting-started","title":"Getting Started","text":"<ol> <li>Find the tool in: OBJ/SOP Tab Menu \u2192 Node Weaver \u2192 Color Palette Configurator</li> <li>The interface shows:</li> <li>Location of default Houdini color palette file</li> <li>Import/export options</li> <li>Main colors list tab</li> <li>Gradient generator control tab</li> <li>Text-based palette tab</li> </ol>"},{"location":"features/color-palette/#features","title":"Features","text":""},{"location":"features/color-palette/#main-color-list","title":"Main Color List","text":"<p>The main colors list determines what gets imported from files or exported to them: - Click any color to edit - Colors appear in the network view color picker (C key) in order, left to right, top to bottom - The \"Color Palette File\" parameter controls:   - Where colors save when using \"Save Colors to File\"   - Where colors load from when using \"Populate Colors from File\"   - Default location matches Houdini's manual color palette save location</p>"},{"location":"features/color-palette/#gradient-generator","title":"Gradient Generator","text":""},{"location":"features/color-palette/#step-1-creating-gradients","title":"Step 1: Creating Gradients","text":"<p>There are three ways to generate gradients:</p> <ol> <li>Manual Entry</li> <li> <p>Set values directly as you would in other Houdini gradients</p> </li> <li> <p>Screen Sampling</p> </li> <li>Click and drag anywhere on screen to sample colors</li> <li> <p>Useful for sampling from images or satellite map data</p> </li> <li> <p>Cosine Formula (credit: Inigo Quilez)</p> </li> <li>Creates smooth, pleasing gradients</li> <li>Parameters:<ul> <li>Brightness, Contrast, Frequency, and Offset</li> <li>Each has R, G, and B values</li> <li>Parameters control how each color channel cycles through the cosine wave</li> </ul> </li> </ol>"},{"location":"features/color-palette/#example-cosine-parameter-effects","title":"Example Cosine Parameter Effects","text":"<p>Examples using only the Red channel:</p> <ul> <li> <p>Brightness 0.5, Contrast 0.5, Frequency 1, Offset 0:   </p> </li> <li> <p>Brightness 0.5, Contrast 1, Frequency 2, Offset 0:   </p> </li> <li> <p>Brightness 0, Contrast 0.25, Frequency 1.5, Offset -0.25:   </p> </li> </ul>"},{"location":"features/color-palette/#built-in-presets","title":"Built-in Presets","text":"<p>The tool includes several presets:</p> <ul> <li> <p>Infrared   </p> </li> <li> <p>Earth/Ice   </p> </li> <li> <p>Aqua, Black, Red, White, Aqua   </p> </li> <li> <p>Flower Blossom   </p> </li> <li> <p>Cosmic   </p> </li> <li> <p>Neon   </p> </li> <li> <p>Peach, Crimson, Peach, Aqua, Peach   </p> </li> <li> <p>Watermelon   </p> </li> <li> <p>Blueberry   </p> </li> </ul>"},{"location":"features/color-palette/#step-2-using-gradient-samples","title":"Step 2: Using Gradient Samples","text":"<p>To add gradient colors to your palette:</p> <ol> <li>Set \"Number of Samples\" and click \"Create Samples From Gradient\"</li> <li>Review generated colors in the multiparm below</li> <li>Colors aren't added to Main Color List yet</li> <li>Adjust, remove, or add colors as needed</li> <li>Click \"Add Gradient Samples to Main Color List\"</li> <li>\"Delete From Here After\": Clears samples after adding</li> <li>\"Add to Top\": Places colors at start of list instead of end</li> </ol>"},{"location":"features/color-palette/#text-based-colors","title":"Text-Based Colors","text":"<p>Import colors from: - Hex codes - Adobe Color CSS format (from color.adobe.com)</p> <p>Options: - Add directly to Main Color List - Generate gradient from colors (evenly spaced)</p>"},{"location":"features/color-palette/#exporting-colors","title":"Exporting Colors","text":"<ul> <li>Save Colors to File: Saves to the location specified in \"Color Palette File\" parameter</li> <li>Must end in <code>/config/opColorPalette.def</code></li> <li>Must save in either:<ul> <li>Houdini preferences folder (default)</li> <li>Custom Houdini tools folder</li> </ul> </li> <li>Palette update takes effect after Houdini restart</li> </ul>"},{"location":"features/color-palette/#sharing-palettes","title":"Sharing Palettes","text":"<ul> <li>If you want to share your palette with anyone, give them the <code>opColorPalette.def</code> file.</li> <li>Same file location requirements apply if the colors are to appear in their Houdini installation.</li> <li>If you want to package an <code>opColorPalette.def</code> file in your own package, put it in an optional folder in case your users already have a color palette they want to keep.</li> </ul>"},{"location":"features/color-palette/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/color-palette/#colors-not-updating","title":"Colors Not Updating","text":"<p>File Location Issues: - File must be named <code>opColorPalette.def</code> - Must be in a <code>/config</code> folder - Base folder must be in either:   - Houdini preferences folder (default)   - Custom Houdini tools folder</p> <p>Example paths: <pre><code>Windows: C:/Users/YourUsername/Documents/HoudiniTools/NodeWeaver/config/opColorPalette.def\nMac: /Users/YourUsername/Documents/HoudiniTools/NodeWeaver/config/opColorPalette.def\nLinux: /home/YourUsername/HoudiniTools/NodeWeaver/config/opColorPalette.def\n</code></pre></p> <p>Multiple Files: - Having <code>opColorPalette.def</code> in external packages overrides preferences folder - Either update external file or delete it</p> <p>After Changes: - Restart Houdini to rescan folders</p>"},{"location":"features/color-palette/#colors-look-different","title":"Colors Look Different","text":"<ul> <li>In Color Editor window, disable \"Enable Color Correction\" in top bar (looks like greyscale ramp)</li> </ul>"},{"location":"features/color-palette/#need-help","title":"Need Help?","text":"<p>If you run into issues: 1. Check if restarting Houdini helps 2. Look through existing issues 3. Open a new issue</p>"},{"location":"features/node-shape/","title":"Node Shape","text":""},{"location":"features/node-shape/#node-shape-creator-hda","title":"Node Shape Creator HDA","text":"<p>\u2190 Back to features</p> <p>The Node Shape Creator makes it easy to design custom node shapes in Houdini. Credit to Simon Fiedler and Bastian Schiffer for doing the initial exploration years ago.</p>"},{"location":"features/node-shape/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Getting Started</li> <li>Features</li> <li>Example Networks</li> <li>Shape Definition</li> <li>Visualization Options<ul> <li>Style Settings</li> <li>Node Appearance</li> <li>Wire Preview</li> </ul> </li> <li>Node Shape Configuration<ul> <li>Basic Settings</li> <li>Wire Settings</li> </ul> </li> <li>Node Shape Guidelines</li> <li>Shape Creation</li> <li>Default Node Stats</li> <li>Wire Handling</li> <li>File Management</li> <li>Save Locations</li> <li>Troubleshooting</li> <li>File Export Issues</li> <li>Need Help?</li> </ul>"},{"location":"features/node-shape/#overview","title":"Overview","text":"<p>Custom node shapes can make your networks more interesting and visually distinct. This tool helps you: - Design custom shapes visually - Test with different wire configurations - Export directly to Houdini's format - Analyze existing node shapes</p>"},{"location":"features/node-shape/#getting-started","title":"Getting Started","text":"<ol> <li>Access via: OBJ/SOP Tab Menu \u2192 Node Weaver \u2192 Custom Node Shape Creator</li> <li>When first opened, the interface provides:</li> <li>Examples of 3 distinct approaches to making shapes that generate a node network for study</li> <li>Shape selection parameters    After shapes have been selected the interface also provides:</li> <li>Node shape information</li> <li>Visualization options</li> <li>A real-time preview (as a 3D model)</li> <li>Shape modification options</li> <li>Export options</li> </ol>"},{"location":"features/node-shape/#features","title":"Features","text":""},{"location":"features/node-shape/#example-networks","title":"Example Networks","text":"<ul> <li>Built-in examples show different approaches to shape creation</li> <li>Each example includes:</li> <li>A subnet showing the technique</li> <li>A sticky note explaining unique features of that technique</li> </ul>"},{"location":"features/node-shape/#shape-definition","title":"Shape Definition","text":"<ul> <li>Input geometry must have at least 5 polygon primitives (main shape and 4 flags)</li> <li>These primitives define the core shape definitions</li> </ul>"},{"location":"features/node-shape/#visualization-options","title":"Visualization Options","text":""},{"location":"features/node-shape/#style-settings","title":"Style Settings","text":"<ul> <li>Four different color palettes representing different Houdini contexts</li> <li>Helps visualize how shape will look in different situations</li> <li>No effect on final output</li> </ul>"},{"location":"features/node-shape/#node-appearance","title":"Node Appearance","text":"<ul> <li>Toggle different node flags to preview appearance</li> <li>Customize node color for visualization</li> <li>Preview with custom icons (load PNG files)</li> <li>No effect on final output</li> </ul>"},{"location":"features/node-shape/#wire-preview","title":"Wire Preview","text":"<ul> <li>Toggle wire visualization</li> <li>Helps verify wire curvature before export</li> <li>Shows connections with varying numbers of inputs/outputs</li> </ul>"},{"location":"features/node-shape/#node-shape-configuration","title":"Node Shape Configuration","text":""},{"location":"features/node-shape/#basic-settings","title":"Basic Settings","text":"<ul> <li>Set node shape name (defines output filename)</li> <li>Configure shape dimensions and positioning</li> <li>Apply transformations and adjustments</li> </ul>"},{"location":"features/node-shape/#wire-settings","title":"Wire Settings","text":"<ul> <li>Adjust input wire curvature</li> <li>Configure output wire curvature</li> <li>Set wire connection points</li> <li>Preview wire behavior with different numbers of connections</li> </ul>"},{"location":"features/node-shape/#node-shape-guidelines","title":"Node Shape Guidelines","text":""},{"location":"features/node-shape/#shape-creation","title":"Shape Creation","text":"<ul> <li>Node shapes require 5 polygon primitives for shape definition</li> <li>Shapes ideally exist inside the 0-1 space in X and Y</li> <li>Center on the 0.5x0.15 point (center of standard nodes)</li> <li>Tool will transform coordinates automatically</li> <li>Some settings allow working outside standard space if needed</li> </ul>"},{"location":"features/node-shape/#default-node-stats","title":"Default Node Stats","text":"<p>For consistency with Houdini's default nodes, consider these measurements: - Most common node size: 1 \u00d7 0.3 units - Most common icon size: 0.24 \u00d7 0.24 units - Input vertical range: -0.2 to -0.09 units - Output vertical range: 0.38 to 0.51 units - Median input/output position: -0.09 \u00d7 0.38 units - Circle node: 0.57 \u00d7 0.57 units with 0.21 \u00d7 0.21 icon</p>"},{"location":"features/node-shape/#wire-handling","title":"Wire Handling","text":"<ul> <li>Input and output curves can be non-centered</li> <li>Centered curves recommended for:</li> <li>Clean wire connections</li> <li>Proper node alignment with layout tools (hold \"A\")</li> <li>Wire curvature can be adjusted:</li> <li>Settings under \"Input Settings &gt; Wire Curvature\"</li> <li>Settings under \"Output Settings &gt; Wire Curvature\"</li> <li>Affects aesthetic appearance of connections</li> </ul>"},{"location":"features/node-shape/#file-management","title":"File Management","text":""},{"location":"features/node-shape/#save-locations","title":"Save Locations","text":"<p>Node shapes can be saved in several locations:</p> <ol> <li>User Preferences (Recommended for Personal Use) <pre><code>$HOUDINI_USER_PREF_DIR/config/NodeShapes\n</code></pre></li> <li>Best for individual use</li> <li> <p>Remember to transfer to new preferences folder when updating Houdini</p> </li> <li> <p>Package Directory (Recommended for Distribution) <pre><code>$NAMEOFPACKAGEPATH/config/NodeShapes\n</code></pre></p> </li> <li>Used by Node Weaver itself</li> <li> <p>Best for package distribution</p> </li> <li> <p>Houdini Installation (Not Recommended) <pre><code>C:/Program Files/Side Effects Software/Houdini XX.X.XXX/houdini/config/NodeShapes\n</code></pre></p> </li> <li>Contains default Houdini shapes</li> <li>Not recommended for custom shapes</li> <li>Highlighting this folder for study vs to save there</li> </ol>"},{"location":"features/node-shape/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/node-shape/#file-export-issues","title":"File Export Issues","text":"<ul> <li>Verify write permissions in target directory</li> <li>Check correct path structure (/config/NodeShapes/)</li> <li>Ensure valid node shape name</li> <li>Restart Houdini after adding new shapes if clicking \"Reload Node Shape Palette\" doesn't work</li> </ul>"},{"location":"features/node-shape/#need-help","title":"Need Help?","text":"<p>If you encounter issues: 1. Try restarting Houdini 2. Check existing issues 3. Open a new issue</p>"},{"location":"features/tool-maker-tools/","title":"Tool Maker Tools","text":""},{"location":"features/tool-maker-tools/#tool-maker-tools","title":"Tool Maker Tools","text":"<p>\u2190 Back to features</p> <p>I created the Tool Maker Tools to handle repetitive tasks I kept running into while developing HDAs. It's still growing as I find new needs, but I've focused on the utilities that have made my TD work easier (that I'm allowed to add for now).</p> <p>Unlike my other tools that focus on customizing Houdini's look, this is more of a collection of helpful utilities that I've built up over time, but it's a bit sparse at the moment.</p>"},{"location":"features/tool-maker-tools/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>HDA Tool Maker</li> <li>Script Generator [In Progress]</li> <li>Copy to Instance Converter</li> <li>Node Weaver Shelf</li> <li>Script Inspector</li> <li>Right-Click Menus</li> <li>Node Context Menu</li> <li>Parameter Context Menu</li> <li>Troubleshooting</li> <li>Need Help?</li> </ul>"},{"location":"features/tool-maker-tools/#overview","title":"Overview","text":"<p>So far, the toolset is small but includes: - Tools to speed up HDA development - Network management helpers - Script generators for common tasks - Parameter manipulation shortcuts</p>"},{"location":"features/tool-maker-tools/#hda-tool-maker","title":"HDA Tool Maker","text":""},{"location":"features/tool-maker-tools/#script-generator-in-progress","title":"Script Generator [In Progress]","text":"<p>I found myself writing the same kinds of menu and action button scripts over and over, so I made this to handle the repetitive parts. It's set up for the most common cases I run into, but you can extend it for your own needs too.</p>"},{"location":"features/tool-maker-tools/#copy-to-instance-converter","title":"Copy to Instance Converter","text":"<p>This one's actually more for artists than TDs - it converts Copy to Points setups to instancing for better performance. I included it here since it's part of the same toolkit, even though it's a bit of an outlier.</p>"},{"location":"features/tool-maker-tools/#node-weaver-shelf","title":"Node Weaver Shelf","text":""},{"location":"features/tool-maker-tools/#script-inspector","title":"Script Inspector","text":"<p>This one's great when you need to see a list of all the scripts involved with a node. I use it when refactoring code or renaming parameters in particular. Select a node and it'll show you all its: - Callback scripts - Default value expressions - Menu scripts</p> <p>Unfortunately, I haven't found a way to access action button scripts - seems to be a Houdini limitation.</p>"},{"location":"features/tool-maker-tools/#right-click-menus","title":"Right-Click Menus","text":""},{"location":"features/tool-maker-tools/#node-context-menu","title":"Node Context Menu","text":"<ul> <li>Node Color Picker: Normally, you need to create a custom color in the Network View Color Palette then apply it, but this removes the need for that.</li> <li>Node Renaming [In Progress]: Working on a better way to rename nodes in bulk with a lot of control.</li> </ul>"},{"location":"features/tool-maker-tools/#parameter-context-menu","title":"Parameter Context Menu","text":"<ul> <li>Value Editor [In Progress]: Building a more powerful way to edit parameter values... same tool as above</li> </ul>"},{"location":"features/tool-maker-tools/#troubleshooting","title":"Troubleshooting","text":"<p>Once I get more tools into here I'm sure troubleshooting will fill out.</p>"},{"location":"features/tool-maker-tools/#need-help","title":"Need Help?","text":"<p>If you encounter issues: 1. Try restarting Houdini 2. Check existing issues 3. Open a new issue</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>core<ul> <li>exceptions.py</li> <li>expr_to_nodes.py</li> <li>instances_from_copytopoints.py</li> <li>script_generator.py</li> <li>script_inspector.py</li> </ul> </li> <li>utils<ul> <li>action_buttons.py</li> <li>colors.py</li> <li>decorators.py</li> <li>files.py</li> <li>hda.py</li> <li>houdini.py</li> <li>mparms.py</li> <li>nodes.py</li> <li>parameters.py</li> <li>qt.py</li> <li>strings.py</li> <li>ui.py</li> </ul> </li> <li>nodes<ul> <li>color_palette_configurator.py</li> <li>custom_node_shape_creator.py</li> <li>inspect_node_shape_file.py</li> </ul> </li> <li>stringweaver<ul> <li>providers<ul> <li>base.py</li> <li>nodes.py</li> <li>parameters.py</li> </ul> </li> <li>services<ul> <li>cache.py</li> <li>history.py</li> </ul> </li> <li>stringweaver.py</li> <li>widgets<ul> <li>options.py</li> <li>results.py</li> <li>search.py</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/core/exceptions/","title":"exceptions.py","text":"<p>Custom exceptions for the NodeWeaver package.</p> <p>This module defines the exception hierarchy used throughout NodeWeaver. All custom exceptions inherit from the base ScriptGeneratorError.</p> Exception Hierarchy <p>ScriptGeneratorError \u251c\u2500\u2500 ValidationError \u2514\u2500\u2500 ConfigurationError</p>"},{"location":"reference/core/exceptions/#core.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>ScriptGeneratorError</code></p> <p>Raised when configuration loading or parsing fails.</p> <p>This exception indicates that there was an error loading or parsing configuration files or settings.</p> Example <p>try: ...     with open(config_path) as f: ...         config = json.load(f) ... except json.JSONDecodeError as e: ...     raise ConfigurationError(f\"Invalid JSON in config: {e}\")</p> Source code in <code>core/exceptions.py</code> <pre><code>class ConfigurationError(ScriptGeneratorError):\n    \"\"\"Raised when configuration loading or parsing fails.\n\n    This exception indicates that there was an error loading or parsing\n    configuration files or settings.\n\n    Example:\n        &gt;&gt;&gt; try:\n        ...     with open(config_path) as f:\n        ...         config = json.load(f)\n        ... except json.JSONDecodeError as e:\n        ...     raise ConfigurationError(f\"Invalid JSON in config: {e}\")\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#core.exceptions.ScriptGeneratorError","title":"<code>ScriptGeneratorError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all NodeWeaver script generation errors.</p> <p>This is the parent class for all custom exceptions in the script generation system. All specific error types should inherit from this class.</p> Example <p>try: ...     # Script generation code ... except ScriptGeneratorError as e: ...     print(f\"Script generation failed: {e}\")</p> Source code in <code>core/exceptions.py</code> <pre><code>class ScriptGeneratorError(Exception):\n    \"\"\"Base exception for all NodeWeaver script generation errors.\n\n    This is the parent class for all custom exceptions in the script generation\n    system. All specific error types should inherit from this class.\n\n    Example:\n        &gt;&gt;&gt; try:\n        ...     # Script generation code\n        ... except ScriptGeneratorError as e:\n        ...     print(f\"Script generation failed: {e}\")\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#core.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>ScriptGeneratorError</code></p> <p>Raised when script validation fails.</p> <p>This exception indicates that script validation failed due to invalid input, missing required fields, or other validation errors.</p> Example <p>if not script_content: ...     raise ValidationError(\"Script content cannot be empty\")</p> Source code in <code>core/exceptions.py</code> <pre><code>class ValidationError(ScriptGeneratorError):\n    \"\"\"Raised when script validation fails.\n\n    This exception indicates that script validation failed due to invalid input,\n    missing required fields, or other validation errors.\n\n    Example:\n        &gt;&gt;&gt; if not script_content:\n        ...     raise ValidationError(\"Script content cannot be empty\")\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/expr_to_nodes/","title":"expr_to_nodes.py","text":"<p>Convert Houdini VOP parameter expressions to node networks.</p> <p>This module provides functionality to convert VOP parameter expressions and references into equivalent node networks, enabling channel expressions to maintain functionality once a material node is converted to a subnet, HDA, or otherwise needs to be compiled.</p> <p>Attributes:</p> Name Type Description <code>MATERIALX_PREFIXES</code> <code>List[str]</code> <p>MaterialX type prefixes used in parameters</p> <p>Functions:</p> Name Description <code>convert_parameter_references</code> <p>Convert parameter references to node networks</p> <code>create_parameter_inputs</code> <p>Create parameter inputs for node inputs</p> <code>process_parameter_inputs</code> <p>Process parameter inputs with various operations</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = hou.node('/obj/geo1/material1')\n&gt;&gt;&gt; convert_parameter_references(node, process_subnodes=True)\n&gt;&gt;&gt; create_parameter_inputs(node, promote_ui=True)\n</code></pre> Notes <p>This module is part of the nodeweaver package for Houdini node manipulation.</p>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.ExpressionParser","title":"<code>ExpressionParser</code>","text":"<p>Parser for Houdini parameter expressions and channel references.</p> <p>Provides utilities for parsing and analyzing parameter expressions, with focus on channel references and MaterialX naming conventions.</p> <p>Attributes:</p> Name Type Description <code>MATERIALX_PREFIXES</code> <code>List[str]</code> <p>List of MaterialX type prefixes ('f_', 'v_', etc.)</p> <p>Methods:</p> Name Description <code>strip_materialx_type_prefixes</code> <p>Removes MaterialX type prefixes from strings</p> <code>parse_and_resolve_channel_reference</code> <p>Resolves channel references to components</p> Example <p>parser = ExpressionParser() clean_name = parser.strip_materialx_type_prefixes(\"f_base_color\") print(clean_name) 'base_color'</p> Source code in <code>core/expr_to_nodes.py</code> <pre><code>class ExpressionParser:\n    \"\"\"Parser for Houdini parameter expressions and channel references.\n\n    Provides utilities for parsing and analyzing parameter expressions,\n    with focus on channel references and MaterialX naming conventions.\n\n    Attributes:\n        MATERIALX_PREFIXES (List[str]): List of MaterialX type prefixes ('f_', 'v_', etc.)\n\n    Methods:\n        strip_materialx_type_prefixes: Removes MaterialX type prefixes from strings\n        parse_and_resolve_channel_reference: Resolves channel references to components\n\n    Example:\n        &gt;&gt;&gt; parser = ExpressionParser()\n        &gt;&gt;&gt; clean_name = parser.strip_materialx_type_prefixes(\"f_base_color\")\n        &gt;&gt;&gt; print(clean_name)\n        'base_color'\n    \"\"\"\n    @staticmethod\n    def strip_materialx_type_prefixes(s: str) -&gt; str:\n        \"\"\"Strip MaterialX type prefixes from strings.\n\n        MaterialX parameters include type prefixes like 'i_', 'f_', 'v_', etc. in\n        some nodes. This function removes these prefixes to get the base string\n        while preserving other underscores in the name.\n\n        Args:\n            s: String that may contain MaterialX type prefixes\n\n        Returns:\n            String with MaterialX type prefixes removed\n\n        Examples:\n            &gt;&gt;&gt; strip_materialx_type_prefixes(\"f_base_color\")\n            'base_color'\n            &gt;&gt;&gt; strip_materialx_type_prefixes(\"v_normal_vector\")\n            'normal_vector'\n            &gt;&gt;&gt; strip_materialx_type_prefixes(\"my_f_param\")  # Won't strip internal prefixes\n            'my_f_param'\n        \"\"\"\n        return _HoudiniExpressionParser.strip_materialx_type_prefixes(s)\n\n    @staticmethod\n    def parse_and_resolve_channel_reference(node: hou.Node, channel_ref: str) -&gt; Tuple[Optional[str], Optional[List], Optional[hou.ParmTuple], Optional[str]]:\n        \"\"\"Parse and resolve a channel reference to its components.\n\n        Handles both absolute and relative channel references, resolving them to their\n        actual parameter locations and component indices.\n\n        Args:\n            node: Node containing the channel reference\n            channel_ref: Channel reference string (e.g., 'ch(\"../param1\")')\n\n        Returns:\n            Tuple containing:\n            - Base parameter name without component suffix\n            - Component indices and names if applicable\n            - Referenced parameter tuple\n            - Channel reference type (ch, chi, chs)\n        \"\"\"\n        return _HoudiniExpressionParser.parse_and_resolve_channel_reference(node, channel_ref)\n\n    @classmethod\n    def create_nodes_from_parameters(cls, target_node: hou.Node,\n                                   parms_data: Dict[str, Dict[str, Union[str, bool]]],\n                                   match_reference_parm_names: bool = True,\n                                   parameters_as_subnet_connectors: bool = True) -&gt; Tuple[hou.Node, Dict[str, str]]:\n        \"\"\"Convert parameter data into a node network.\n\n        Creates a subnet containing nodes that represent the parameter expressions\n        and references, properly connected to maintain the same behavior.\n\n        Args:\n            target_node: Node whose parameters are being converted\n            parms_data: Dictionary mapping parameter names to their expression data\n            match_reference_parm_names: Whether to maintain referenced parameter names\n            parameters_as_subnet_connectors: Whether to use subnet connectors for parameters\n\n        Returns:\n            Tuple containing:\n            - Created subnet node\n            - Dictionary of simple channel references\n        \"\"\"\n        parser = _HoudiniExpressionParser(target_node)\n        return parser.create_nodes_from_parameters(parms_data, match_reference_parm_names, parameters_as_subnet_connectors)\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.ExpressionParser.create_nodes_from_parameters","title":"<code>create_nodes_from_parameters(target_node, parms_data, match_reference_parm_names=True, parameters_as_subnet_connectors=True)</code>  <code>classmethod</code>","text":"<p>Convert parameter data into a node network.</p> <p>Creates a subnet containing nodes that represent the parameter expressions and references, properly connected to maintain the same behavior.</p> <p>Parameters:</p> Name Type Description Default <code>target_node</code> <code>Node</code> <p>Node whose parameters are being converted</p> required <code>parms_data</code> <code>Dict[str, Dict[str, Union[str, bool]]]</code> <p>Dictionary mapping parameter names to their expression data</p> required <code>match_reference_parm_names</code> <code>bool</code> <p>Whether to maintain referenced parameter names</p> <code>True</code> <code>parameters_as_subnet_connectors</code> <code>bool</code> <p>Whether to use subnet connectors for parameters</p> <code>True</code> <p>Returns:</p> Type Description <code>Node</code> <p>Tuple containing:</p> <code>Dict[str, str]</code> <ul> <li>Created subnet node</li> </ul> <code>Tuple[Node, Dict[str, str]]</code> <ul> <li>Dictionary of simple channel references</li> </ul> Source code in <code>core/expr_to_nodes.py</code> <pre><code>@classmethod\ndef create_nodes_from_parameters(cls, target_node: hou.Node,\n                               parms_data: Dict[str, Dict[str, Union[str, bool]]],\n                               match_reference_parm_names: bool = True,\n                               parameters_as_subnet_connectors: bool = True) -&gt; Tuple[hou.Node, Dict[str, str]]:\n    \"\"\"Convert parameter data into a node network.\n\n    Creates a subnet containing nodes that represent the parameter expressions\n    and references, properly connected to maintain the same behavior.\n\n    Args:\n        target_node: Node whose parameters are being converted\n        parms_data: Dictionary mapping parameter names to their expression data\n        match_reference_parm_names: Whether to maintain referenced parameter names\n        parameters_as_subnet_connectors: Whether to use subnet connectors for parameters\n\n    Returns:\n        Tuple containing:\n        - Created subnet node\n        - Dictionary of simple channel references\n    \"\"\"\n    parser = _HoudiniExpressionParser(target_node)\n    return parser.create_nodes_from_parameters(parms_data, match_reference_parm_names, parameters_as_subnet_connectors)\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.ExpressionParser.parse_and_resolve_channel_reference","title":"<code>parse_and_resolve_channel_reference(node, channel_ref)</code>  <code>staticmethod</code>","text":"<p>Parse and resolve a channel reference to its components.</p> <p>Handles both absolute and relative channel references, resolving them to their actual parameter locations and component indices.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node containing the channel reference</p> required <code>channel_ref</code> <code>str</code> <p>Channel reference string (e.g., 'ch(\"../param1\")')</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Tuple containing:</p> <code>Optional[List]</code> <ul> <li>Base parameter name without component suffix</li> </ul> <code>Optional[ParmTuple]</code> <ul> <li>Component indices and names if applicable</li> </ul> <code>Optional[str]</code> <ul> <li>Referenced parameter tuple</li> </ul> <code>Tuple[Optional[str], Optional[List], Optional[ParmTuple], Optional[str]]</code> <ul> <li>Channel reference type (ch, chi, chs)</li> </ul> Source code in <code>core/expr_to_nodes.py</code> <pre><code>@staticmethod\ndef parse_and_resolve_channel_reference(node: hou.Node, channel_ref: str) -&gt; Tuple[Optional[str], Optional[List], Optional[hou.ParmTuple], Optional[str]]:\n    \"\"\"Parse and resolve a channel reference to its components.\n\n    Handles both absolute and relative channel references, resolving them to their\n    actual parameter locations and component indices.\n\n    Args:\n        node: Node containing the channel reference\n        channel_ref: Channel reference string (e.g., 'ch(\"../param1\")')\n\n    Returns:\n        Tuple containing:\n        - Base parameter name without component suffix\n        - Component indices and names if applicable\n        - Referenced parameter tuple\n        - Channel reference type (ch, chi, chs)\n    \"\"\"\n    return _HoudiniExpressionParser.parse_and_resolve_channel_reference(node, channel_ref)\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.ExpressionParser.strip_materialx_type_prefixes","title":"<code>strip_materialx_type_prefixes(s)</code>  <code>staticmethod</code>","text":"<p>Strip MaterialX type prefixes from strings.</p> <p>MaterialX parameters include type prefixes like 'i_', 'f_', 'v_', etc. in some nodes. This function removes these prefixes to get the base string while preserving other underscores in the name.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String that may contain MaterialX type prefixes</p> required <p>Returns:</p> Type Description <code>str</code> <p>String with MaterialX type prefixes removed</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; strip_materialx_type_prefixes(\"f_base_color\")\n'base_color'\n&gt;&gt;&gt; strip_materialx_type_prefixes(\"v_normal_vector\")\n'normal_vector'\n&gt;&gt;&gt; strip_materialx_type_prefixes(\"my_f_param\")  # Won't strip internal prefixes\n'my_f_param'\n</code></pre> Source code in <code>core/expr_to_nodes.py</code> <pre><code>@staticmethod\ndef strip_materialx_type_prefixes(s: str) -&gt; str:\n    \"\"\"Strip MaterialX type prefixes from strings.\n\n    MaterialX parameters include type prefixes like 'i_', 'f_', 'v_', etc. in\n    some nodes. This function removes these prefixes to get the base string\n    while preserving other underscores in the name.\n\n    Args:\n        s: String that may contain MaterialX type prefixes\n\n    Returns:\n        String with MaterialX type prefixes removed\n\n    Examples:\n        &gt;&gt;&gt; strip_materialx_type_prefixes(\"f_base_color\")\n        'base_color'\n        &gt;&gt;&gt; strip_materialx_type_prefixes(\"v_normal_vector\")\n        'normal_vector'\n        &gt;&gt;&gt; strip_materialx_type_prefixes(\"my_f_param\")  # Won't strip internal prefixes\n        'my_f_param'\n    \"\"\"\n    return _HoudiniExpressionParser.strip_materialx_type_prefixes(s)\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.convert_references_to_nodes","title":"<code>convert_references_to_nodes(node, process_subnodes=None, match_reference_names=None, use_subnet_connectors=None)</code>","text":"<p>Convert parameter references in a node to parameter nodes.</p> <p>Converts channel references and expressions in parameters to equivalent parameter nodes that preserve functionality.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to process</p> required <code>process_subnodes</code> <code>Optional[bool]</code> <p>Whether to process child nodes. If None, will prompt user</p> <code>None</code> <code>match_reference_names</code> <code>Optional[bool]</code> <p>Whether to match referenced parameter names. If None, will prompt user</p> <code>None</code> <code>use_subnet_connectors</code> <code>Optional[bool]</code> <p>Whether to use subnet connectors. If None, will prompt user</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid</p> <code>RuntimeError</code> <p>If parameter conversion fails</p> Example <p>node = hou.node('/obj/geo1/material1') convert_parameter_references(node, True, True, False)</p> Source code in <code>core/expr_to_nodes.py</code> <pre><code>def convert_references_to_nodes(node: hou.Node,\n                              process_subnodes: bool = None,\n                              match_reference_names: bool = None,\n                              use_subnet_connectors: bool = None) -&gt; None:\n    \"\"\"Convert parameter references in a node to parameter nodes.\n\n    Converts channel references and expressions in parameters to equivalent\n    parameter nodes that preserve functionality.\n\n    Args:\n        node (hou.Node): The node to process\n        process_subnodes (Optional[bool]): Whether to process child nodes.\n            If None, will prompt user\n        match_reference_names (Optional[bool]): Whether to match referenced parameter names.\n            If None, will prompt user\n        use_subnet_connectors (Optional[bool]): Whether to use subnet connectors.\n            If None, will prompt user\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If node is None or invalid\n        RuntimeError: If parameter conversion fails\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/geo1/material1')\n        &gt;&gt;&gt; convert_parameter_references(node, True, True, False)\n    \"\"\"\n    convert_parm_references_to_parm_nodes(\n        node,\n        process_subnodes,\n        match_reference_names,\n        use_subnet_connectors\n    )\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.create_parameter_inputs","title":"<code>create_parameter_inputs(node, add_node_prefix=None, promote_ui=None, process_selected=None)</code>","text":"<p>Create parameter inputs for all inputs on a node.</p> <p>Generates parameter nodes for each input on the specified node, with options for naming, UI promotion, and batch processing.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to process</p> required <code>add_node_prefix</code> <code>Optional[bool]</code> <p>Whether to add node name prefix to parameters. If None, will prompt user</p> <code>None</code> <code>promote_ui</code> <code>Optional[bool]</code> <p>Whether to promote parameters to the UI. If None, will prompt user</p> <code>None</code> <code>process_selected</code> <code>Optional[bool]</code> <p>Whether to process all selected nodes. If None, will prompt user</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid</p> <code>RuntimeError</code> <p>If parameter creation fails</p> Example <p>node = hou.node('/obj/geo1/material1') create_parameter_inputs(node, True, True, False)</p> Source code in <code>core/expr_to_nodes.py</code> <pre><code>def create_parameter_inputs(node: hou.Node,\n                          add_node_prefix: bool = None,\n                          promote_ui: bool = None,\n                          process_selected: bool = None) -&gt; None:\n    \"\"\"Create parameter inputs for all inputs on a node.\n\n    Generates parameter nodes for each input on the specified node, with options\n    for naming, UI promotion, and batch processing.\n\n    Args:\n        node (hou.Node): The node to process\n        add_node_prefix (Optional[bool]): Whether to add node name prefix to parameters.\n            If None, will prompt user\n        promote_ui (Optional[bool]): Whether to promote parameters to the UI.\n            If None, will prompt user\n        process_selected (Optional[bool]): Whether to process all selected nodes.\n            If None, will prompt user\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If node is None or invalid\n        RuntimeError: If parameter creation fails\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/geo1/material1')\n        &gt;&gt;&gt; create_parameter_inputs(node, True, True, False)\n    \"\"\"\n    create_parm_inputs_for_all_inputs(\n        node,\n        add_node_prefix,\n        promote_ui,\n        process_selected\n    )\n</code></pre>"},{"location":"reference/core/expr_to_nodes/#core.expr_to_nodes.process_parameter_inputs","title":"<code>process_parameter_inputs(nodes, delete=None, hide=None, convert=None)</code>","text":"<p>Process parameter inputs with various operations.</p> <p>Performs bulk operations on parameter inputs including deletion, visibility changes, and type conversion across one or multiple nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Union[Node, List[Node]]</code> <p>Node or list of nodes to process</p> required <code>delete</code> <code>Optional[bool]</code> <p>Whether to delete parameter inputs. If None, will prompt user</p> <code>None</code> <code>hide</code> <code>Optional[int]</code> <p>Hide state for parameter inputs. - 0: No change - 1: Show - 2: Hide If None, will prompt user</p> <code>None</code> <code>convert</code> <code>Optional[int]</code> <p>Conversion mode for parameters. - 0: None - 1: Subnet - 2: Parameter If None, will prompt user</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If nodes is empty or invalid</p> <code>TypeError</code> <p>If parameter values are incorrect types</p> <code>RuntimeError</code> <p>If operations fail</p> Example <p>node = hou.node('/obj/geo1/material1') process_parameter_inputs(node, delete=False, hide=1, convert=0)</p> Source code in <code>core/expr_to_nodes.py</code> <pre><code>def process_parameter_inputs(nodes: Union[hou.Node, List[hou.Node]],\n                           delete: bool = None,\n                           hide: int = None,\n                           convert: int = None) -&gt; None:\n    \"\"\"Process parameter inputs with various operations.\n\n    Performs bulk operations on parameter inputs including deletion, visibility changes,\n    and type conversion across one or multiple nodes.\n\n    Args:\n        nodes (Union[hou.Node, List[hou.Node]]): Node or list of nodes to process\n        delete (Optional[bool]): Whether to delete parameter inputs.\n            If None, will prompt user\n        hide (Optional[int]): Hide state for parameter inputs.\n            - 0: No change\n            - 1: Show\n            - 2: Hide\n            If None, will prompt user\n        convert (Optional[int]): Conversion mode for parameters.\n            - 0: None\n            - 1: Subnet\n            - 2: Parameter\n            If None, will prompt user\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If nodes is empty or invalid\n        TypeError: If parameter values are incorrect types\n        RuntimeError: If operations fail\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/geo1/material1')\n        &gt;&gt;&gt; process_parameter_inputs(node, delete=False, hide=1, convert=0)\n    \"\"\"\n    process_all_parm_inputs(nodes, delete, hide, convert)\n</code></pre>"},{"location":"reference/core/instances_from_copytopoints/","title":"instances_from_copytopoints.py","text":""},{"location":"reference/core/script_generator/","title":"script_generator.py","text":"<p>Public interface for generating Houdini scripts.</p> <p>This module provides high-level functionality for generating menu scripts, action button scripts, and managing script templates in Houdini Digital Assets. It abstracts away the implementation details while providing a clean, type-safe API.</p> Example <p>generator = ScriptGenerator.create(\"menu\") script = generator.generate_script( ...     category=\"group_selection\", ...     name=\"single_group_type\", ...     options={\"option1\": \"hou.geometryType.Points\"} ... )</p> <p>Classes:</p> Name Description <code>ScriptGenerator</code> <p>High-level script generation interface</p> <code>HDAScriptManager</code> <p>Script generation in HDAs</p>"},{"location":"reference/core/script_generator/#core.script_generator.HDAScriptManager","title":"<code>HDAScriptManager</code>","text":"<p>Manages script generation in Houdini Digital Assets.</p> <p>This class provides high-level functionality for handling script generation UI and script creation in HDAs.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>Node</code> <p>The HDA node containing the UI</p> <code>generator</code> <code>ScriptGenerator</code> <p>The script generator instance</p> <p>Methods:</p> Name Description <code>update</code> <p>Updates UI based on current selections</p> <code>generate</code> <p>Creates script from current UI values</p> <code>get_node</code> <p>Returns the associated HDA node</p> Example <p>node = hou.node('/obj/myHDA') script_ui = ScriptGenerator(node) script_ui.update() result = script_ui.generate()</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initialization fails</p> <code>RuntimeError</code> <p>If script generation operations fail</p> Source code in <code>core/script_generator.py</code> <pre><code>class HDAScriptManager:\n    \"\"\"Manages script generation in Houdini Digital Assets.\n\n    This class provides high-level functionality for handling script generation\n    UI and script creation in HDAs.\n\n    Attributes:\n        node (hou.Node): The HDA node containing the UI\n        generator (ScriptGenerator): The script generator instance\n\n    Methods:\n        update(): Updates UI based on current selections\n        generate(): Creates script from current UI values\n        get_node(): Returns the associated HDA node\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/myHDA')\n        &gt;&gt;&gt; script_ui = ScriptGenerator(node)\n        &gt;&gt;&gt; script_ui.update()\n        &gt;&gt;&gt; result = script_ui.generate()\n\n    Raises:\n        ValueError: If initialization fails\n        RuntimeError: If script generation operations fail\n    \"\"\"\n\n    def __init__(self, node: hou.Node) -&gt; None:\n        \"\"\"Initialize with HDA node.\n\n        Args:\n            node (hou.Node): HDA node containing script generation UI.\n                Must be a valid Digital Asset node.\n\n        Raises:\n            ValueError: If node is None or not an HDA node\n            TypeError: If node is not of type hou.Node\n        \"\"\"\n        self._impl = _script_generator.HDAScriptUI(node)\n\n    def update_ui(self) -&gt; None:\n        \"\"\"Update the HDA UI based on current selections.\n\n        Updates parameter values, enables/disables fields, and refreshes menu items\n        based on the current state of UI selections in the HDA.\n\n        Raises:\n            RuntimeError: If UI parameters cannot be updated\n            ValueError: If parameter values are invalid\n        \"\"\"\n        self._impl.update_ui()\n\n    def generate_script(self) -&gt; Optional[str]:\n        \"\"\"Generate script based on current UI selections.\n\n        Creates a Python script by processing the current parameter values in the HDA UI\n        and generating appropriate script content using the configured generator.\n\n        Returns:\n            Optional[str]: The generated script if successful, None if generation fails\n                due to invalid selections or missing required values.\n\n        Raises:\n            ValueError: If required parameters are missing or invalid\n            RuntimeError: If script generation fails\n\n        Example:\n            &gt;&gt;&gt; script = hda.generate_script()\n            &gt;&gt;&gt; if script:\n            ...     hou.node('/obj/geo1').setParms({'script': script})\n        \"\"\"\n        return self._impl.generate_script()\n\n    @property\n    def node(self) -&gt; hou.Node:\n        \"\"\"Get the associated HDA node.\n\n        Returns:\n            hou.Node: The HDA node containing the script generation UI\n\n        Raises:\n            RuntimeError: If node reference is invalid or None\n        \"\"\"\n        return self._impl.node\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.HDAScriptManager.node","title":"<code>node: hou.Node</code>  <code>property</code>","text":"<p>Get the associated HDA node.</p> <p>Returns:</p> Type Description <code>Node</code> <p>hou.Node: The HDA node containing the script generation UI</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If node reference is invalid or None</p>"},{"location":"reference/core/script_generator/#core.script_generator.HDAScriptManager.__init__","title":"<code>__init__(node)</code>","text":"<p>Initialize with HDA node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>HDA node containing script generation UI. Must be a valid Digital Asset node.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or not an HDA node</p> <code>TypeError</code> <p>If node is not of type hou.Node</p> Source code in <code>core/script_generator.py</code> <pre><code>def __init__(self, node: hou.Node) -&gt; None:\n    \"\"\"Initialize with HDA node.\n\n    Args:\n        node (hou.Node): HDA node containing script generation UI.\n            Must be a valid Digital Asset node.\n\n    Raises:\n        ValueError: If node is None or not an HDA node\n        TypeError: If node is not of type hou.Node\n    \"\"\"\n    self._impl = _script_generator.HDAScriptUI(node)\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.HDAScriptManager.generate_script","title":"<code>generate_script()</code>","text":"<p>Generate script based on current UI selections.</p> <p>Creates a Python script by processing the current parameter values in the HDA UI and generating appropriate script content using the configured generator.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The generated script if successful, None if generation fails due to invalid selections or missing required values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required parameters are missing or invalid</p> <code>RuntimeError</code> <p>If script generation fails</p> Example <p>script = hda.generate_script() if script: ...     hou.node('/obj/geo1').setParms({'script': script})</p> Source code in <code>core/script_generator.py</code> <pre><code>def generate_script(self) -&gt; Optional[str]:\n    \"\"\"Generate script based on current UI selections.\n\n    Creates a Python script by processing the current parameter values in the HDA UI\n    and generating appropriate script content using the configured generator.\n\n    Returns:\n        Optional[str]: The generated script if successful, None if generation fails\n            due to invalid selections or missing required values.\n\n    Raises:\n        ValueError: If required parameters are missing or invalid\n        RuntimeError: If script generation fails\n\n    Example:\n        &gt;&gt;&gt; script = hda.generate_script()\n        &gt;&gt;&gt; if script:\n        ...     hou.node('/obj/geo1').setParms({'script': script})\n    \"\"\"\n    return self._impl.generate_script()\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.HDAScriptManager.update_ui","title":"<code>update_ui()</code>","text":"<p>Update the HDA UI based on current selections.</p> <p>Updates parameter values, enables/disables fields, and refreshes menu items based on the current state of UI selections in the HDA.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If UI parameters cannot be updated</p> <code>ValueError</code> <p>If parameter values are invalid</p> Source code in <code>core/script_generator.py</code> <pre><code>def update_ui(self) -&gt; None:\n    \"\"\"Update the HDA UI based on current selections.\n\n    Updates parameter values, enables/disables fields, and refreshes menu items\n    based on the current state of UI selections in the HDA.\n\n    Raises:\n        RuntimeError: If UI parameters cannot be updated\n        ValueError: If parameter values are invalid\n    \"\"\"\n    self._impl.update_ui()\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator","title":"<code>ScriptGenerator</code>","text":"<p>High-level interface for script generation.</p> <p>This class provides methods to generate Houdini scripts from templates while handling configuration loading and validation.</p> Example <p>generator = ScriptGenerator.create('menu') script = generator.generate_script('groups', 'by_type', { ...     'type': 'points' ... })</p> Source code in <code>core/script_generator.py</code> <pre><code>class ScriptGenerator:\n    \"\"\"High-level interface for script generation.\n\n    This class provides methods to generate Houdini scripts from templates\n    while handling configuration loading and validation.\n\n    Example:\n        &gt;&gt;&gt; generator = ScriptGenerator.create('menu')\n        &gt;&gt;&gt; script = generator.generate_script('groups', 'by_type', {\n        ...     'type': 'points'\n        ... })\n    \"\"\"\n\n    @classmethod\n    def create(cls, script_type: ScriptType,\n                config_path: Optional[Path] = None) -&gt; 'ScriptGenerator':\n        \"\"\"Create a script generator of the specified type.\n\n        Args:\n            script_type: Type of scripts to generate (\"menu\" or \"action\")\n            config_path: Optional custom path to config file\n\n        Returns:\n            Configured script generator\n\n        Raises:\n            ValueError: If script_type is invalid\n            ConfigurationError: If config loading fails\n\n        Example:\n            &gt;&gt;&gt; generator = ScriptGenerator.create('menu')\n            &gt;&gt;&gt; generator.generate_script(...)\n        \"\"\"\n        if config_path is None:\n            config_path = Path(__file__).parent / \"config/script_generator/default.json\"\n\n        generator_cls = {\n            \"menu\": _script_generator.MenuScriptGenerator,\n            \"action\": _script_generator.ActionButtonGenerator\n        }.get(script_type)\n\n        if not generator_cls:\n            raise ValueError(f\"Invalid script type: {script_type}\")\n\n        return cls(generator_cls(config_path))\n\n    def __init__(self, impl: Union[\n        _script_generator.MenuScriptGenerator,\n        _script_generator.ActionButtonGenerator\n    ]) -&gt; None:\n        \"\"\"Initialize with implementation object.\n\n        Args:\n            impl (ScriptGeneratorImpl): Implementation object containing template handling logic\n\n        Returns:\n            None\n\n        Raises:\n            TypeError: If impl is not a ScriptGeneratorImpl instance\n            ValueError: If impl is None\n        \"\"\"\n        self._impl = impl\n\n    def get_categories(self) -&gt; List[str]:\n        \"\"\"Get available script categories.\n\n        Retrieves all supported script template categories from the configuration.\n\n        Returns:\n            List[str]: List of available script categories.\n                Example: ['node', 'tool', 'shelf']\n\n        Raises:\n            RuntimeError: If no categories are configured\n        \"\"\"\n        return self._impl.get_categories()\n\n    def get_templates(self, category: str) -&gt; List[str]:\n        \"\"\"Get available templates in a category.\n\n        Retrieves all template names available within the specified category.\n\n        Args:\n            category (str): Category to get templates for. Must be a valid category name.\n\n        Returns:\n            List[str]: List of template names available in the specified category.\n                Example: ['delete_unused', 'create_group', 'export_fbx']\n\n        Raises:\n            KeyError: If category doesn't exist\n            ValueError: If category is empty or None\n        \"\"\"\n        return self._impl.get_templates(category)\n\n    def get_template_info(self, category: str, name: str) -&gt; Dict[str, any]:\n        \"\"\"Get detailed information about a template.\n\n        Retrieves metadata and configuration details for a specific template.\n\n        Args:\n            category (str): Template category to look in\n            name (str): Name of the template to get info for\n\n        Returns:\n            Dict[str, Any]: Dictionary containing template metadata including:\n                - description: Template description\n                - parameters: Template parameters\n                - defaults: Default values\n                - options: Available options\n\n        Raises:\n            ValidationError: If template not found\n            KeyError: If category doesn't exist\n        \"\"\"\n        template = self._impl.get_template(category, name)\n        if not template:\n            raise ValidationError(f\"Template {name} not found in {category}\")\n\n        return {\n            \"name\": template.name,\n            \"category\": template.category,\n            \"description\": template.description,\n            \"options\": {\n                name: {\n                    \"label\": opt[\"label\"],\n                    \"options\": opt[\"options\"]\n                }\n                for name, opt in template.options.items()\n            }\n        }\n\n    def generate_script(self, category: str, name: str,\n                        options: Dict[str, str]) -&gt; str:\n        \"\"\"Generate a script from a template.\n\n        Creates a Python script by applying the provided options to the specified template.\n\n        Args:\n            category (str): Template category (e.g. 'tool', 'shelf', 'node')\n            name (str): Template name to use for generation\n            options (Dict[str, Any]): Dictionary of option values to apply to the template.\n                Keys must match template parameter names.\n\n        Returns:\n            str: The generated script code ready for use in Houdini\n\n        Raises:\n            ValidationError: If script generation fails due to:\n                - Invalid template category or name\n                - Missing required options\n                - Option value validation failures\n            KeyError: If template not found\n\n        Example:\n            &gt;&gt;&gt; options = {'name': 'myTool', 'type': 'delete'}\n            &gt;&gt;&gt; script = generate('tool', 'basic', options)\n        \"\"\"\n        return self._impl.generate_script(category, name, options)\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.__init__","title":"<code>__init__(impl)</code>","text":"<p>Initialize with implementation object.</p> <p>Parameters:</p> Name Type Description Default <code>impl</code> <code>ScriptGeneratorImpl</code> <p>Implementation object containing template handling logic</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If impl is not a ScriptGeneratorImpl instance</p> <code>ValueError</code> <p>If impl is None</p> Source code in <code>core/script_generator.py</code> <pre><code>def __init__(self, impl: Union[\n    _script_generator.MenuScriptGenerator,\n    _script_generator.ActionButtonGenerator\n]) -&gt; None:\n    \"\"\"Initialize with implementation object.\n\n    Args:\n        impl (ScriptGeneratorImpl): Implementation object containing template handling logic\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If impl is not a ScriptGeneratorImpl instance\n        ValueError: If impl is None\n    \"\"\"\n    self._impl = impl\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.create","title":"<code>create(script_type, config_path=None)</code>  <code>classmethod</code>","text":"<p>Create a script generator of the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>script_type</code> <code>ScriptType</code> <p>Type of scripts to generate (\"menu\" or \"action\")</p> required <code>config_path</code> <code>Optional[Path]</code> <p>Optional custom path to config file</p> <code>None</code> <p>Returns:</p> Type Description <code>ScriptGenerator</code> <p>Configured script generator</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If script_type is invalid</p> <code>ConfigurationError</code> <p>If config loading fails</p> Example <p>generator = ScriptGenerator.create('menu') generator.generate_script(...)</p> Source code in <code>core/script_generator.py</code> <pre><code>@classmethod\ndef create(cls, script_type: ScriptType,\n            config_path: Optional[Path] = None) -&gt; 'ScriptGenerator':\n    \"\"\"Create a script generator of the specified type.\n\n    Args:\n        script_type: Type of scripts to generate (\"menu\" or \"action\")\n        config_path: Optional custom path to config file\n\n    Returns:\n        Configured script generator\n\n    Raises:\n        ValueError: If script_type is invalid\n        ConfigurationError: If config loading fails\n\n    Example:\n        &gt;&gt;&gt; generator = ScriptGenerator.create('menu')\n        &gt;&gt;&gt; generator.generate_script(...)\n    \"\"\"\n    if config_path is None:\n        config_path = Path(__file__).parent / \"config/script_generator/default.json\"\n\n    generator_cls = {\n        \"menu\": _script_generator.MenuScriptGenerator,\n        \"action\": _script_generator.ActionButtonGenerator\n    }.get(script_type)\n\n    if not generator_cls:\n        raise ValueError(f\"Invalid script type: {script_type}\")\n\n    return cls(generator_cls(config_path))\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.generate_script","title":"<code>generate_script(category, name, options)</code>","text":"<p>Generate a script from a template.</p> <p>Creates a Python script by applying the provided options to the specified template.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Template category (e.g. 'tool', 'shelf', 'node')</p> required <code>name</code> <code>str</code> <p>Template name to use for generation</p> required <code>options</code> <code>Dict[str, Any]</code> <p>Dictionary of option values to apply to the template. Keys must match template parameter names.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated script code ready for use in Houdini</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If script generation fails due to: - Invalid template category or name - Missing required options - Option value validation failures</p> <code>KeyError</code> <p>If template not found</p> Example <p>options = {'name': 'myTool', 'type': 'delete'} script = generate('tool', 'basic', options)</p> Source code in <code>core/script_generator.py</code> <pre><code>def generate_script(self, category: str, name: str,\n                    options: Dict[str, str]) -&gt; str:\n    \"\"\"Generate a script from a template.\n\n    Creates a Python script by applying the provided options to the specified template.\n\n    Args:\n        category (str): Template category (e.g. 'tool', 'shelf', 'node')\n        name (str): Template name to use for generation\n        options (Dict[str, Any]): Dictionary of option values to apply to the template.\n            Keys must match template parameter names.\n\n    Returns:\n        str: The generated script code ready for use in Houdini\n\n    Raises:\n        ValidationError: If script generation fails due to:\n            - Invalid template category or name\n            - Missing required options\n            - Option value validation failures\n        KeyError: If template not found\n\n    Example:\n        &gt;&gt;&gt; options = {'name': 'myTool', 'type': 'delete'}\n        &gt;&gt;&gt; script = generate('tool', 'basic', options)\n    \"\"\"\n    return self._impl.generate_script(category, name, options)\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.get_categories","title":"<code>get_categories()</code>","text":"<p>Get available script categories.</p> <p>Retrieves all supported script template categories from the configuration.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of available script categories. Example: ['node', 'tool', 'shelf']</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no categories are configured</p> Source code in <code>core/script_generator.py</code> <pre><code>def get_categories(self) -&gt; List[str]:\n    \"\"\"Get available script categories.\n\n    Retrieves all supported script template categories from the configuration.\n\n    Returns:\n        List[str]: List of available script categories.\n            Example: ['node', 'tool', 'shelf']\n\n    Raises:\n        RuntimeError: If no categories are configured\n    \"\"\"\n    return self._impl.get_categories()\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.get_template_info","title":"<code>get_template_info(category, name)</code>","text":"<p>Get detailed information about a template.</p> <p>Retrieves metadata and configuration details for a specific template.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Template category to look in</p> required <code>name</code> <code>str</code> <p>Name of the template to get info for</p> required <p>Returns:</p> Type Description <code>Dict[str, any]</code> <p>Dict[str, Any]: Dictionary containing template metadata including: - description: Template description - parameters: Template parameters - defaults: Default values - options: Available options</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If template not found</p> <code>KeyError</code> <p>If category doesn't exist</p> Source code in <code>core/script_generator.py</code> <pre><code>def get_template_info(self, category: str, name: str) -&gt; Dict[str, any]:\n    \"\"\"Get detailed information about a template.\n\n    Retrieves metadata and configuration details for a specific template.\n\n    Args:\n        category (str): Template category to look in\n        name (str): Name of the template to get info for\n\n    Returns:\n        Dict[str, Any]: Dictionary containing template metadata including:\n            - description: Template description\n            - parameters: Template parameters\n            - defaults: Default values\n            - options: Available options\n\n    Raises:\n        ValidationError: If template not found\n        KeyError: If category doesn't exist\n    \"\"\"\n    template = self._impl.get_template(category, name)\n    if not template:\n        raise ValidationError(f\"Template {name} not found in {category}\")\n\n    return {\n        \"name\": template.name,\n        \"category\": template.category,\n        \"description\": template.description,\n        \"options\": {\n            name: {\n                \"label\": opt[\"label\"],\n                \"options\": opt[\"options\"]\n            }\n            for name, opt in template.options.items()\n        }\n    }\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.ScriptGenerator.get_templates","title":"<code>get_templates(category)</code>","text":"<p>Get available templates in a category.</p> <p>Retrieves all template names available within the specified category.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Category to get templates for. Must be a valid category name.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of template names available in the specified category. Example: ['delete_unused', 'create_group', 'export_fbx']</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If category doesn't exist</p> <code>ValueError</code> <p>If category is empty or None</p> Source code in <code>core/script_generator.py</code> <pre><code>def get_templates(self, category: str) -&gt; List[str]:\n    \"\"\"Get available templates in a category.\n\n    Retrieves all template names available within the specified category.\n\n    Args:\n        category (str): Category to get templates for. Must be a valid category name.\n\n    Returns:\n        List[str]: List of template names available in the specified category.\n            Example: ['delete_unused', 'create_group', 'export_fbx']\n\n    Raises:\n        KeyError: If category doesn't exist\n        ValueError: If category is empty or None\n    \"\"\"\n    return self._impl.get_templates(category)\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.create_action_script","title":"<code>create_action_script(category, name, options)</code>","text":"<p>Create an action button script from a template.</p> <p>Creates a Python script for a Houdini action button based on the specified template and options. Handles proper formatting and validation for button script requirements.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Template category ('tool', 'shelf', etc.)</p> required <code>name</code> <code>str</code> <p>Template name to use for generation</p> required <code>options</code> <code>Dict[str, Any]</code> <p>Configuration options for script generation. Values depend on the template requirements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated Python script code ready for use in Houdini</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If script generation fails due to invalid options</p> <code>KeyError</code> <p>If template or category not found</p> Example <p>script = create_action_script( ...     \"file_operations\", ...     \"open_in_explorer\", ...     {\"option1\": \"hip\"} ... )</p> Source code in <code>core/script_generator.py</code> <pre><code>def create_action_script(category: str, name: str,\n                        options: Dict[str, str]) -&gt; str:\n    \"\"\"Create an action button script from a template.\n\n    Creates a Python script for a Houdini action button based on the specified\n    template and options. Handles proper formatting and validation for button\n    script requirements.\n\n    Args:\n        category (str): Template category ('tool', 'shelf', etc.)\n        name (str): Template name to use for generation\n        options (Dict[str, Any]): Configuration options for script generation.\n            Values depend on the template requirements.\n\n    Returns:\n        str: The generated Python script code ready for use in Houdini\n\n    Raises:\n        ValidationError: If script generation fails due to invalid options\n        KeyError: If template or category not found\n\n    Example:\n        &gt;&gt;&gt; script = create_action_script(\n        ...     \"file_operations\",\n        ...     \"open_in_explorer\",\n        ...     {\"option1\": \"hip\"}\n        ... )\n    \"\"\"\n    generator = ScriptGenerator.create(\"action\")\n    return generator.generate_script(category, name, options)\n</code></pre>"},{"location":"reference/core/script_generator/#core.script_generator.create_menu_script","title":"<code>create_menu_script(category, name, options)</code>","text":"<p>Create a menu script from a template.</p> <p>Convenience function for quick menu script generation without creating a generator instance.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Template category</p> required <code>name</code> <code>str</code> <p>Template name</p> required <code>options</code> <code>Dict[str, str]</code> <p>Dictionary of option values</p> required <p>Returns:</p> Type Description <code>str</code> <p>Generated menu script</p> Example <p>script = create_menu_script( ...     \"group_selection\", ...     \"single_group_type\", ...     {\"option1\": \"hou.geometryType.Points\"} ... )</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If template or options are invalid</p> Source code in <code>core/script_generator.py</code> <pre><code>def create_menu_script(category: str, name: str,\n                        options: Dict[str, str]) -&gt; str:\n    \"\"\"Create a menu script from a template.\n\n    Convenience function for quick menu script generation without\n    creating a generator instance.\n\n    Args:\n        category: Template category\n        name: Template name\n        options: Dictionary of option values\n\n    Returns:\n        Generated menu script\n\n    Example:\n        &gt;&gt;&gt; script = create_menu_script(\n        ...     \"group_selection\",\n        ...     \"single_group_type\",\n        ...     {\"option1\": \"hou.geometryType.Points\"}\n        ... )\n\n    Raises:\n        ValidationError: If template or options are invalid\n    \"\"\"\n    generator = ScriptGenerator.create(\"menu\")\n    return generator.generate_script(category, name, options)\n</code></pre>"},{"location":"reference/core/script_inspector/","title":"script_inspector.py","text":"<p>Public interface for inspecting scripts and callbacks in Houdini nodes.</p> <p>This module provides functionality for searching, analyzing and extracting scripts from nodes, including callbacks, expressions, menu scripts, and conditionals.</p> Example <p>inspector = ScriptInspector() inspector.print_scripts_in_selected_nodes()</p> <p>Classes:</p> Name Description <code>ScriptInspector</code> <p>Main script inspection functionality</p>"},{"location":"reference/core/script_inspector/#core.script_inspector.ScriptInspector","title":"<code>ScriptInspector</code>","text":"<p>Inspects and analyzes scripts and callbacks in Houdini nodes.</p> <p>Provides methods to search, analyze and extract scripts from node parameters, including callbacks, expressions, menu scripts, and conditionals.</p> <p>Attributes:</p> Name Type Description <code>search_mode</code> <code>Optional[int]</code> <p>Current search mode (None until first search)</p> <code>search_str</code> <code>Optional[str]</code> <p>Current search string (None until first search)</p> Example <p>inspector = ScriptInspector() scripts = inspector.search_scripts(node) for script in scripts: ...     print(f\"{script['type']}: {script['script']}\")</p> Source code in <code>core/script_inspector.py</code> <pre><code>class ScriptInspector:\n    \"\"\"Inspects and analyzes scripts and callbacks in Houdini nodes.\n\n    Provides methods to search, analyze and extract scripts from node parameters,\n    including callbacks, expressions, menu scripts, and conditionals.\n\n    Attributes:\n        search_mode: Current search mode (None until first search)\n        search_str: Current search string (None until first search)\n\n    Example:\n        &gt;&gt;&gt; inspector = ScriptInspector()\n        &gt;&gt;&gt; scripts = inspector.search_scripts(node)\n        &gt;&gt;&gt; for script in scripts:\n        ...     print(f\"{script['type']}: {script['script']}\")\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ScriptInspector.\n\n        Creates a new ScriptInspector instance with default settings for analyzing\n        Houdini scripts.\n        \"\"\"\n        self.search_mode: Optional[int] = None\n        self.search_str: Optional[str] = None\n\n    def search_scripts(self, node: hou.Node) -&gt; List[Dict[str, str]]:\n        \"\"\"Search for scripts in a node's parameters.\n\n        Args:\n            node: Node to search\n\n        Returns:\n            List of found scripts with their metadata:\n            - parameter: Parameter name\n            - type: Script type (callback, expression, etc.)\n            - script: Formatted script content\n\n        Raises:\n            ValueError: If node is None\n\n        Example:\n            &gt;&gt;&gt; scripts = inspector.search_scripts(node)\n            &gt;&gt;&gt; for script in scripts:\n            ...     print(f\"{script['parameter']}: {script['script']}\")\n        \"\"\"\n        if not node:\n            raise ValueError(\"Node cannot be None\")\n\n        # Get search parameters if not already set\n        if self.search_mode is None:\n            self.search_mode, self.search_str = _script_inspector.prompt_search_params()\n            if self.search_mode is None:\n                return []\n\n        return _script_inspector.find_scripts(node, self.search_mode, self.search_str)\n\n    @reload_before_run\n    def print_scripts_in_selected_nodes(self) -&gt; None:\n        \"\"\"Search and print scripts from all selected nodes.\n\n        Finds all script-type parameters in the selected nodes and prints their contents,\n        organized by node and parameter name.\n\n        Raises:\n            RuntimeError: If no nodes are selected\n            ValueError: If selected nodes contain no script parameters\n\n        Example:\n            &gt;&gt;&gt; inspector = ScriptInspector()\n            &gt;&gt;&gt; inspector.search_selected()  # Prints all scripts in selected nodes\n        \"\"\"\n        sel = hou.selectedNodes()\n        if not sel:\n            hou.ui.displayMessage(\"Please select a node first.\",\n                                severity=hou.severityType.Error)\n            return\n\n        for node in sel:\n            scripts = self.search_scripts(node)\n\n            if scripts:\n                print(f\"\\nScripts found in {node.path()}:\")\n                print(\"-\" * 40)\n                for script in scripts:\n                    print(f\"Parameter: {script['parameter']}\")\n                    print(script['script'])\n                    print(\"-\" * 40)\n\n    @staticmethod\n    def format_script(label: str, script: str, indent: int = 4) -&gt; str:\n        \"\"\"Format a script with proper indentation and wrapping.\n\n        Takes raw script content and formats it with consistent indentation, line wrapping\n        and optional label prefix.\n\n        Args:\n            label (str): Script type label to prefix (e.g. 'Python', 'VEX')\n            script (str): The raw script content to format\n            indent (int, optional): Number of spaces for indentation. Defaults to 4.\n\n        Returns:\n            str: The formatted script string with proper indentation and wrapping\n\n        Raises:\n            ValueError: If script is None or empty\n            TypeError: If indent is not an integer\n\n        Example:\n            &gt;&gt;&gt; inspector = ScriptInspector()\n            &gt;&gt;&gt; formatted = inspector.format_script(\"Python\", \"def foo():\\\\n    pass\", 4)\n        \"\"\"\n        return _script_inspector.format_script(label, script, indent)\n</code></pre>"},{"location":"reference/core/script_inspector/#core.script_inspector.ScriptInspector.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the ScriptInspector.</p> <p>Creates a new ScriptInspector instance with default settings for analyzing Houdini scripts.</p> Source code in <code>core/script_inspector.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the ScriptInspector.\n\n    Creates a new ScriptInspector instance with default settings for analyzing\n    Houdini scripts.\n    \"\"\"\n    self.search_mode: Optional[int] = None\n    self.search_str: Optional[str] = None\n</code></pre>"},{"location":"reference/core/script_inspector/#core.script_inspector.ScriptInspector.format_script","title":"<code>format_script(label, script, indent=4)</code>  <code>staticmethod</code>","text":"<p>Format a script with proper indentation and wrapping.</p> <p>Takes raw script content and formats it with consistent indentation, line wrapping and optional label prefix.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Script type label to prefix (e.g. 'Python', 'VEX')</p> required <code>script</code> <code>str</code> <p>The raw script content to format</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted script string with proper indentation and wrapping</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If script is None or empty</p> <code>TypeError</code> <p>If indent is not an integer</p> Example <p>inspector = ScriptInspector() formatted = inspector.format_script(\"Python\", \"def foo():\\n    pass\", 4)</p> Source code in <code>core/script_inspector.py</code> <pre><code>@staticmethod\ndef format_script(label: str, script: str, indent: int = 4) -&gt; str:\n    \"\"\"Format a script with proper indentation and wrapping.\n\n    Takes raw script content and formats it with consistent indentation, line wrapping\n    and optional label prefix.\n\n    Args:\n        label (str): Script type label to prefix (e.g. 'Python', 'VEX')\n        script (str): The raw script content to format\n        indent (int, optional): Number of spaces for indentation. Defaults to 4.\n\n    Returns:\n        str: The formatted script string with proper indentation and wrapping\n\n    Raises:\n        ValueError: If script is None or empty\n        TypeError: If indent is not an integer\n\n    Example:\n        &gt;&gt;&gt; inspector = ScriptInspector()\n        &gt;&gt;&gt; formatted = inspector.format_script(\"Python\", \"def foo():\\\\n    pass\", 4)\n    \"\"\"\n    return _script_inspector.format_script(label, script, indent)\n</code></pre>"},{"location":"reference/core/script_inspector/#core.script_inspector.ScriptInspector.print_scripts_in_selected_nodes","title":"<code>print_scripts_in_selected_nodes()</code>","text":"<p>Search and print scripts from all selected nodes.</p> <p>Finds all script-type parameters in the selected nodes and prints their contents, organized by node and parameter name.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no nodes are selected</p> <code>ValueError</code> <p>If selected nodes contain no script parameters</p> Example <p>inspector = ScriptInspector() inspector.search_selected()  # Prints all scripts in selected nodes</p> Source code in <code>core/script_inspector.py</code> <pre><code>@reload_before_run\ndef print_scripts_in_selected_nodes(self) -&gt; None:\n    \"\"\"Search and print scripts from all selected nodes.\n\n    Finds all script-type parameters in the selected nodes and prints their contents,\n    organized by node and parameter name.\n\n    Raises:\n        RuntimeError: If no nodes are selected\n        ValueError: If selected nodes contain no script parameters\n\n    Example:\n        &gt;&gt;&gt; inspector = ScriptInspector()\n        &gt;&gt;&gt; inspector.search_selected()  # Prints all scripts in selected nodes\n    \"\"\"\n    sel = hou.selectedNodes()\n    if not sel:\n        hou.ui.displayMessage(\"Please select a node first.\",\n                            severity=hou.severityType.Error)\n        return\n\n    for node in sel:\n        scripts = self.search_scripts(node)\n\n        if scripts:\n            print(f\"\\nScripts found in {node.path()}:\")\n            print(\"-\" * 40)\n            for script in scripts:\n                print(f\"Parameter: {script['parameter']}\")\n                print(script['script'])\n                print(\"-\" * 40)\n</code></pre>"},{"location":"reference/core/script_inspector/#core.script_inspector.ScriptInspector.search_scripts","title":"<code>search_scripts(node)</code>","text":"<p>Search for scripts in a node's parameters.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to search</p> required <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List of found scripts with their metadata:</p> <code>List[Dict[str, str]]</code> <ul> <li>parameter: Parameter name</li> </ul> <code>List[Dict[str, str]]</code> <ul> <li>type: Script type (callback, expression, etc.)</li> </ul> <code>List[Dict[str, str]]</code> <ul> <li>script: Formatted script content</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None</p> Example <p>scripts = inspector.search_scripts(node) for script in scripts: ...     print(f\"{script['parameter']}: {script['script']}\")</p> Source code in <code>core/script_inspector.py</code> <pre><code>def search_scripts(self, node: hou.Node) -&gt; List[Dict[str, str]]:\n    \"\"\"Search for scripts in a node's parameters.\n\n    Args:\n        node: Node to search\n\n    Returns:\n        List of found scripts with their metadata:\n        - parameter: Parameter name\n        - type: Script type (callback, expression, etc.)\n        - script: Formatted script content\n\n    Raises:\n        ValueError: If node is None\n\n    Example:\n        &gt;&gt;&gt; scripts = inspector.search_scripts(node)\n        &gt;&gt;&gt; for script in scripts:\n        ...     print(f\"{script['parameter']}: {script['script']}\")\n    \"\"\"\n    if not node:\n        raise ValueError(\"Node cannot be None\")\n\n    # Get search parameters if not already set\n    if self.search_mode is None:\n        self.search_mode, self.search_str = _script_inspector.prompt_search_params()\n        if self.search_mode is None:\n            return []\n\n    return _script_inspector.find_scripts(node, self.search_mode, self.search_str)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/","title":"color_palette_configurator.py","text":"<p>Color palette configuration node implementation for Houdini.</p> <p>This module provides functionality for creating, modifying, and managing color palettes in Houdini through a specialized node interface. It handles:</p> <ul> <li>Importing and exporting Houdini color palette files</li> <li>Converting between hex and RGB color formats</li> <li>Gradient-based color generation including cosine gradients</li> <li>Text-based color parsing and extraction</li> <li>Screen color sampling</li> <li>Default Houdini color palette management</li> </ul> <p>The module uses a singleton pattern to ensure consistent state management per node instance, with separate managers for gradient and text-based operations.</p> <p>Classes:</p> Name Description <code>ColorPaletteConfigurator</code> <p>Core color palette management</p> <code>GradientManager</code> <p>Gradient-based color operations</p> <code>TextColorManager</code> <p>Text-based color parsing and conversion</p> Note <p>This node implementation relies on the nodeweaver.utils.colors module for core color manipulation functions and nodeweaver.config for gradient presets.</p>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator","title":"<code>ColorPaletteConfigurator</code>","text":"<p>Manages color palette configuration node functionality.</p> <p>This class handles importing, exporting and modifying color palettes for use in Houdini's interface. It maintains a singleton instance per node to ensure consistent state.</p> <p>Attributes:</p> Name Type Description <code>node</code> <p>HDA node this instance manages</p> Example <p>configurator = ColorPaletteConfigurator.get_instance(node) configurator.import_colors()</p> Note <p>Use get_instance() instead of direct instantiation to maintain singleton pattern.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>class ColorPaletteConfigurator:\n    \"\"\"Manages color palette configuration node functionality.\n\n    This class handles importing, exporting and modifying color palettes\n    for use in Houdini's interface. It maintains a singleton instance per node\n    to ensure consistent state.\n\n    Attributes:\n        node: HDA node this instance manages\n\n    Example:\n        &gt;&gt;&gt; configurator = ColorPaletteConfigurator.get_instance(node)\n        &gt;&gt;&gt; configurator.import_colors()\n\n    Note:\n        Use get_instance() instead of direct instantiation to maintain\n        singleton pattern.\n    \"\"\"\n    _instances: ClassVar[Dict[str, 'ColorPaletteConfigurator']] = {}\n\n    @classmethod\n    def get_instance(cls, node: hou.Node) -&gt; 'ColorPaletteConfigurator':\n        \"\"\"Get or create configurator instance for a node.\n\n        Args:\n            node: HDA node requiring configurator\n\n        Returns:\n            Singleton instance for the node\n\n        Example:\n            &gt;&gt;&gt; configurator = ColorPaletteConfigurator.get_instance(node)\n            &gt;&gt;&gt; configurator.reset_colors()\n        \"\"\"\n        node_path = node.path()\n        if node_path not in cls._instances:\n            cls._instances[node_path] = cls(node)\n        return cls._instances[node_path]\n\n    def __init__(self, node: hou.Node):\n        \"\"\"Initialize with the node instance.\n\n        Args:\n            node (hou.Node): The Houdini node containing color palette parameters.\n                Must be a valid node with color parameters.\n\n        Raises:\n            ValueError: If node is None or invalid\n            TypeError: If node is not of type hou.Node\n        \"\"\"\n        self.node = node\n\n    # Core color palette methods\n\n    def import_colors(self) -&gt; None:\n        \"\"\"Import colors from a palette file.\n\n        Reads colors from a Houdini color palette file and creates corresponding\n        entries in the node's color list.\n\n        Notes:\n            - Validates file format and existence\n            - Prompts for confirmation if colors exist\n            - Converts color formats automatically\n            - Updates both RGB and hex representations\n\n        Example:\n            &gt;&gt;&gt; configurator.import_colors()  # Imports from node's file parameter\n        \"\"\"\n        mparm = self.node.parm(\"colors\")\n\n        if mparm.eval():\n            if hou.ui.displayMessage(\"Colors appear to exist in the main list already. Are you sure you'd like to overwrite?\",\n                                   buttons=(\"Yes\", \"No\")) == 1:\n                return\n\n        file_path = self.node.parm(\"file\").evalAsString()\n        if not colors.validate_palette_file(file_path):\n            return\n\n        mparm.set(0)\n        with open(file_path, \"r\") as file:\n            lines = file.read().splitlines()\n            count = lines.pop(0)\n            lines.reverse()\n            lines = [line for line in lines if line]\n\n            for i, line in enumerate(lines):\n                color = line.split(\" \")\n                color.pop(0)\n                mparm.insertMultiParmInstance(i)\n                self.node.parmTuple(f\"rgb{i+1}\").set(color)\n                self.node.parm(f\"hex{i+1}\").set(\n                    colors.float_rgb_to_hex(float(color[0]), float(color[1]), float(color[2]))\n                )\n\n    def export_colors(self) -&gt; None:\n        \"\"\"Export colors to a palette file.\n\n        Saves the current color palette configuration to a file in the specified format.\n\n        Returns:\n            bool: True if export successful, False otherwise\n\n        Raises:\n            ValueError: If filepath is invalid or format_type not supported\n            IOError: If file cannot be written\n\n        Example:\n            &gt;&gt;&gt; configurator = ColorPaletteConfigurator(node)\n            &gt;&gt;&gt; success = configurator.export_palette('C:/colors.json')\n        \"\"\"\n        if hou.ui.displayMessage(\"Would you like export these colors?\",\n                               buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n        file_path = self.node.parm(\"file\").evalAsString()\n        if not colors.validate_palette_file(file_path, importing=False):\n            return\n\n        mparm = self.node.parm(\"colors\")\n        lines = []\n\n        for i in range(mparm.evalAsInt()):\n            line = \"D3\"\n            color = self.node.parmTuple(f\"rgb{i+1}\").evalAsFloats()\n            for j in color:\n                line += f\" {j:.3}\"\n            lines.append(line)\n\n        lines.reverse()\n        lines.insert(0, mparm.evalAsString())\n        lines_s = \"\\n\".join(lines)\n\n        with open(file_path, \"w+\") as file:\n            file.write(lines_s)\n\n        hou.ui.displayMessage(\"Colors successfully exported.\")\n\n    def reset_colors(self) -&gt; None:\n        \"\"\"Reset colors to Houdini defaults.\n\n        Resets all color parameters to their original Houdini default values, discarding\n        any custom color palette settings.\n\n        Raises:\n            RuntimeError: If default values cannot be restored\n            ValueError: If color parameters are invalid\n\n        Example:\n            &gt;&gt;&gt; configurator = ColorPaletteConfigurator(node)\n            &gt;&gt;&gt; configurator.reset_colors()  # Restores default Houdini colors\n        \"\"\"\n        if hou.ui.displayMessage(\"Would you like to reset the colors to the Houdini Defaults?\",\n                               buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n        default_colors = colors.load_default_palette()\n        default_colors.reverse()\n        mparm = self.node.parm(\"colors\")\n        mparm.set(0)\n\n        for i, color in enumerate(default_colors):\n            mparm.insertMultiParmInstance(i)\n            self.node.parmTuple(f\"rgb{i+1}\").set(color)\n            self.node.parm(f\"hex{i+1}\").set(\n                colors.float_rgb_to_hex(color[0], color[1], color[2])\n            )\n\n    def update_hex(self, kwargs: Dict) -&gt; None:\n        \"\"\"Update hex value when RGB changed.\n\n        Callback method that updates the hex color parameter whenever RGB values\n        are modified by the user.\n\n        Raises:\n            ValueError: If RGB values are invalid\n            RuntimeError: If hex parameter update fails\n\n        Example:\n            &gt;&gt;&gt; # Automatically called when RGB parameters change\n            &gt;&gt;&gt; # node.parm('r').set(255)  # Triggers hex update\n        \"\"\"\n        value = self.node.parmTuple(kwargs[\"script_parm\"]).evalAsFloats()\n        hex = colors.float_rgb_to_hex(value[0], value[1], value[2])\n        self.node.parm(f\"hex{kwargs['script_multiparm_index']}\").set(hex)\n\n    def update_rgb(self, kwargs: Dict) -&gt; None:\n        \"\"\"Update RGB values when hex changed.\n\n        Callback method that updates the RGB color parameters whenever the hex color\n        value is modified by the user.\n\n        Raises:\n            ValueError: If hex value is invalid\n            RuntimeError: If RGB parameter updates fail\n\n        Example:\n            &gt;&gt;&gt; # Automatically called when hex parameter changes\n            &gt;&gt;&gt; # node.parm('hex').set('#FF0000')  # Triggers RGB update\n        \"\"\"\n        hex = colors.hex_to_float_rgb(kwargs[\"script_value0\"])\n        self.node.parmTuple(f\"rgb{kwargs['script_multiparm_index']}\").set(hex)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.__init__","title":"<code>__init__(node)</code>","text":"<p>Initialize with the node instance.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The Houdini node containing color palette parameters. Must be a valid node with color parameters.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid</p> <code>TypeError</code> <p>If node is not of type hou.Node</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def __init__(self, node: hou.Node):\n    \"\"\"Initialize with the node instance.\n\n    Args:\n        node (hou.Node): The Houdini node containing color palette parameters.\n            Must be a valid node with color parameters.\n\n    Raises:\n        ValueError: If node is None or invalid\n        TypeError: If node is not of type hou.Node\n    \"\"\"\n    self.node = node\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.export_colors","title":"<code>export_colors()</code>","text":"<p>Export colors to a palette file.</p> <p>Saves the current color palette configuration to a file in the specified format.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>None</code> <p>True if export successful, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filepath is invalid or format_type not supported</p> <code>IOError</code> <p>If file cannot be written</p> Example <p>configurator = ColorPaletteConfigurator(node) success = configurator.export_palette('C:/colors.json')</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def export_colors(self) -&gt; None:\n    \"\"\"Export colors to a palette file.\n\n    Saves the current color palette configuration to a file in the specified format.\n\n    Returns:\n        bool: True if export successful, False otherwise\n\n    Raises:\n        ValueError: If filepath is invalid or format_type not supported\n        IOError: If file cannot be written\n\n    Example:\n        &gt;&gt;&gt; configurator = ColorPaletteConfigurator(node)\n        &gt;&gt;&gt; success = configurator.export_palette('C:/colors.json')\n    \"\"\"\n    if hou.ui.displayMessage(\"Would you like export these colors?\",\n                           buttons=(\"Yes\", \"No\")) == 1:\n        return\n\n    file_path = self.node.parm(\"file\").evalAsString()\n    if not colors.validate_palette_file(file_path, importing=False):\n        return\n\n    mparm = self.node.parm(\"colors\")\n    lines = []\n\n    for i in range(mparm.evalAsInt()):\n        line = \"D3\"\n        color = self.node.parmTuple(f\"rgb{i+1}\").evalAsFloats()\n        for j in color:\n            line += f\" {j:.3}\"\n        lines.append(line)\n\n    lines.reverse()\n    lines.insert(0, mparm.evalAsString())\n    lines_s = \"\\n\".join(lines)\n\n    with open(file_path, \"w+\") as file:\n        file.write(lines_s)\n\n    hou.ui.displayMessage(\"Colors successfully exported.\")\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.get_instance","title":"<code>get_instance(node)</code>  <code>classmethod</code>","text":"<p>Get or create configurator instance for a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>HDA node requiring configurator</p> required <p>Returns:</p> Type Description <code>ColorPaletteConfigurator</code> <p>Singleton instance for the node</p> Example <p>configurator = ColorPaletteConfigurator.get_instance(node) configurator.reset_colors()</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>@classmethod\ndef get_instance(cls, node: hou.Node) -&gt; 'ColorPaletteConfigurator':\n    \"\"\"Get or create configurator instance for a node.\n\n    Args:\n        node: HDA node requiring configurator\n\n    Returns:\n        Singleton instance for the node\n\n    Example:\n        &gt;&gt;&gt; configurator = ColorPaletteConfigurator.get_instance(node)\n        &gt;&gt;&gt; configurator.reset_colors()\n    \"\"\"\n    node_path = node.path()\n    if node_path not in cls._instances:\n        cls._instances[node_path] = cls(node)\n    return cls._instances[node_path]\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.import_colors","title":"<code>import_colors()</code>","text":"<p>Import colors from a palette file.</p> <p>Reads colors from a Houdini color palette file and creates corresponding entries in the node's color list.</p> Notes <ul> <li>Validates file format and existence</li> <li>Prompts for confirmation if colors exist</li> <li>Converts color formats automatically</li> <li>Updates both RGB and hex representations</li> </ul> Example <p>configurator.import_colors()  # Imports from node's file parameter</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def import_colors(self) -&gt; None:\n    \"\"\"Import colors from a palette file.\n\n    Reads colors from a Houdini color palette file and creates corresponding\n    entries in the node's color list.\n\n    Notes:\n        - Validates file format and existence\n        - Prompts for confirmation if colors exist\n        - Converts color formats automatically\n        - Updates both RGB and hex representations\n\n    Example:\n        &gt;&gt;&gt; configurator.import_colors()  # Imports from node's file parameter\n    \"\"\"\n    mparm = self.node.parm(\"colors\")\n\n    if mparm.eval():\n        if hou.ui.displayMessage(\"Colors appear to exist in the main list already. Are you sure you'd like to overwrite?\",\n                               buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n    file_path = self.node.parm(\"file\").evalAsString()\n    if not colors.validate_palette_file(file_path):\n        return\n\n    mparm.set(0)\n    with open(file_path, \"r\") as file:\n        lines = file.read().splitlines()\n        count = lines.pop(0)\n        lines.reverse()\n        lines = [line for line in lines if line]\n\n        for i, line in enumerate(lines):\n            color = line.split(\" \")\n            color.pop(0)\n            mparm.insertMultiParmInstance(i)\n            self.node.parmTuple(f\"rgb{i+1}\").set(color)\n            self.node.parm(f\"hex{i+1}\").set(\n                colors.float_rgb_to_hex(float(color[0]), float(color[1]), float(color[2]))\n            )\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.reset_colors","title":"<code>reset_colors()</code>","text":"<p>Reset colors to Houdini defaults.</p> <p>Resets all color parameters to their original Houdini default values, discarding any custom color palette settings.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If default values cannot be restored</p> <code>ValueError</code> <p>If color parameters are invalid</p> Example <p>configurator = ColorPaletteConfigurator(node) configurator.reset_colors()  # Restores default Houdini colors</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def reset_colors(self) -&gt; None:\n    \"\"\"Reset colors to Houdini defaults.\n\n    Resets all color parameters to their original Houdini default values, discarding\n    any custom color palette settings.\n\n    Raises:\n        RuntimeError: If default values cannot be restored\n        ValueError: If color parameters are invalid\n\n    Example:\n        &gt;&gt;&gt; configurator = ColorPaletteConfigurator(node)\n        &gt;&gt;&gt; configurator.reset_colors()  # Restores default Houdini colors\n    \"\"\"\n    if hou.ui.displayMessage(\"Would you like to reset the colors to the Houdini Defaults?\",\n                           buttons=(\"Yes\", \"No\")) == 1:\n        return\n\n    default_colors = colors.load_default_palette()\n    default_colors.reverse()\n    mparm = self.node.parm(\"colors\")\n    mparm.set(0)\n\n    for i, color in enumerate(default_colors):\n        mparm.insertMultiParmInstance(i)\n        self.node.parmTuple(f\"rgb{i+1}\").set(color)\n        self.node.parm(f\"hex{i+1}\").set(\n            colors.float_rgb_to_hex(color[0], color[1], color[2])\n        )\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_hex","title":"<code>update_hex(kwargs)</code>","text":"<p>Update hex value when RGB changed.</p> <p>Callback method that updates the hex color parameter whenever RGB values are modified by the user.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If RGB values are invalid</p> <code>RuntimeError</code> <p>If hex parameter update fails</p> Example Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def update_hex(self, kwargs: Dict) -&gt; None:\n    \"\"\"Update hex value when RGB changed.\n\n    Callback method that updates the hex color parameter whenever RGB values\n    are modified by the user.\n\n    Raises:\n        ValueError: If RGB values are invalid\n        RuntimeError: If hex parameter update fails\n\n    Example:\n        &gt;&gt;&gt; # Automatically called when RGB parameters change\n        &gt;&gt;&gt; # node.parm('r').set(255)  # Triggers hex update\n    \"\"\"\n    value = self.node.parmTuple(kwargs[\"script_parm\"]).evalAsFloats()\n    hex = colors.float_rgb_to_hex(value[0], value[1], value[2])\n    self.node.parm(f\"hex{kwargs['script_multiparm_index']}\").set(hex)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_hex--automatically-called-when-rgb-parameters-change","title":"Automatically called when RGB parameters change","text":""},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_hex--nodeparmrset255-triggers-hex-update","title":"node.parm('r').set(255)  # Triggers hex update","text":""},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_rgb","title":"<code>update_rgb(kwargs)</code>","text":"<p>Update RGB values when hex changed.</p> <p>Callback method that updates the RGB color parameters whenever the hex color value is modified by the user.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If hex value is invalid</p> <code>RuntimeError</code> <p>If RGB parameter updates fail</p> Example Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def update_rgb(self, kwargs: Dict) -&gt; None:\n    \"\"\"Update RGB values when hex changed.\n\n    Callback method that updates the RGB color parameters whenever the hex color\n    value is modified by the user.\n\n    Raises:\n        ValueError: If hex value is invalid\n        RuntimeError: If RGB parameter updates fail\n\n    Example:\n        &gt;&gt;&gt; # Automatically called when hex parameter changes\n        &gt;&gt;&gt; # node.parm('hex').set('#FF0000')  # Triggers RGB update\n    \"\"\"\n    hex = colors.hex_to_float_rgb(kwargs[\"script_value0\"])\n    self.node.parmTuple(f\"rgb{kwargs['script_multiparm_index']}\").set(hex)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_rgb--automatically-called-when-hex-parameter-changes","title":"Automatically called when hex parameter changes","text":""},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.ColorPaletteConfigurator.update_rgb--nodeparmhexsetff0000-triggers-rgb-update","title":"node.parm('hex').set('#FF0000')  # Triggers RGB update","text":""},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager","title":"<code>GradientManager</code>","text":"<p>Manages gradient-based color operations for the color palette configurator.</p> <p>Handles creation, sampling, and management of color gradients including cosine-based gradient generation.</p> Example <p>manager = GradientManager.get_instance(node) manager.create_cosine_gradient()</p> Note <p>Use get_instance() instead of direct instantiation.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>class GradientManager:\n    \"\"\"Manages gradient-based color operations for the color palette configurator.\n\n    Handles creation, sampling, and management of color gradients including\n    cosine-based gradient generation.\n\n    Example:\n        &gt;&gt;&gt; manager = GradientManager.get_instance(node)\n        &gt;&gt;&gt; manager.create_cosine_gradient()\n\n    Note:\n        Use get_instance() instead of direct instantiation.\n    \"\"\"\n    _instances: ClassVar[Dict[str, 'GradientManager']] = {}\n\n    @classmethod\n    def get_instance(cls, node: hou.Node) -&gt; 'GradientManager':\n        \"\"\"Get or create gradient manager instance for a node.\n\n        Args:\n            node (hou.Node): The Houdini node to manage gradients for.\n\n        Returns:\n            GradientManager: Instance associated with the node.\n\n        Raises:\n            TypeError: If node is not a hou.Node instance.\n        \"\"\"\n        node_path = node.path()\n        if node_path not in cls._instances:\n            cls._instances[node_path] = cls(node)\n        return cls._instances[node_path]\n\n    def __init__(self, node: hou.Node):\n        \"\"\"Initialize with the node instance.\n\n        Args:\n            node (hou.Node): The Houdini node containing gradient parameters.\n\n        Raises:\n            ValueError: If node is None or invalid.\n        \"\"\"\n        self.node = node\n\n    def sample_gradient(self, kwargs: Dict, index: int = -1) -&gt; None:\n        \"\"\"Sample a color from the defined gradient.\n\n        Args:\n            kwargs (Dict): Parameter kwargs from callback.\n            index (int, optional): Specific index to sample. Defaults to -1 for current.\n\n        Raises:\n            ValueError: If gradient parameters are invalid.\n        \"\"\"\n        ramp = self.node.parm(\"sample_grad\").eval()\n        i = kwargs['script_multiparm_index'] if index == -1 else index\n        parm = self.node.parm(f\"grad_pos{i}\").eval()\n        sample = ramp.lookup(parm)\n        self.node.parmTuple(f\"grad_rgb{i}\").set(sample)\n\n    def reset_gradient_samples(self, kwargs: Dict) -&gt; None:\n        \"\"\"Reset colors on all gradient samples.\n\n        Args:\n            kwargs (Dict): Parameter kwargs from callback.\n\n        Raises:\n            RuntimeError: If gradient reset fails.\n        \"\"\"\n        for i in range(self.node.parm(\"grads\").eval()):\n            self.sample_gradient(kwargs, i+1)\n\n    def add_gradient_samples(self) -&gt; None:\n        \"\"\"Add gradient samples to the main color list.\n\n        Includes the option to delete samples from the gradient multiparm afterwards.\n\n        Raises:\n            RuntimeError: If sample addition fails.\n            ValueError: If color parameters are invalid.\n        \"\"\"\n        colors = self.node.parm(\"colors\")\n        tog_top = self.node.evalParm(\"tog_grad_top\")\n\n        for i in range(self.node.parm(\"grads\").eval()):\n            if self.node.parm(f\"tog_grad{i+1}\").eval():\n                color = self.node.parmTuple(f\"grad_rgb{i+1}\").eval()\n                iter = [colors.eval(), 0][tog_top]\n                colors.insertMultiParmInstance(iter)\n                self.node.parmTuple(f\"rgb{iter+1}\").set(color)\n                self.node.parm(f\"hex{iter+1}\").set(\n                    colors.float_rgb_to_hex(float(color[0]), float(color[1]), float(color[2]))\n                )\n\n        if self.node.parm(\"tog_del_grad\").eval():\n            self.node.parm(\"grads\").set(0)\n\n        hou.ui.displayMessage(\"Colors successfully added to main list.\")\n\n    def create_auto_samples(self) -&gt; None:\n        \"\"\"Create automatically spaced gradient samples.\n\n        Creates evenly spaced samples along the gradient, optionally replacing\n        existing samples.\n\n        Raises:\n            RuntimeError: If auto sample creation fails.\n            ValueError: If sample count is invalid.\n        \"\"\"\n        if self.node.parm(\"grads\").eval() &gt; 0:\n            if hou.ui.displayMessage(\"Replace gradient samples with automatically spaced ones?\",\n                                   buttons=(\"Yes\", \"No\")) == 1:\n                return\n\n        total = self.node.parm(\"grad_auto_sample\").eval()\n        samples = self.node.parm(\"grads\")\n        samples.set(0)\n\n        for i in range(total):\n            samples.insertMultiParmInstance(i)\n            frac = float(i)/float(total-1)\n            self.node.parm(f\"grad_pos{i+1}\").set(frac)\n            self.sample_gradient({\"script_multiparm_index\":-1}, i+1)\n\n    def create_cosine_gradient(self) -&gt; None:\n        \"\"\"Create a cosine-based color gradient.\n\n        Generates a gradient using cosine functions with configurable\n        parameters for each color channel.\n\n        Notes:\n            - Uses separate cosine functions for R, G, B channels\n            - Maintains smooth color transitions\n            - Automatically updates gradient samples\n\n        Example:\n            &gt;&gt;&gt; manager.create_cosine_gradient()\n        \"\"\"\n        def calc_val(t: float) -&gt; Tuple[float, float, float]:\n            color = []\n            for i in [\"r\", \"g\", \"b\"]:\n                color.append(\n                    self.node.evalParm(f\"grad_a{i}\") +\n                    self.node.evalParm(f\"grad_b{i}\") *\n                    math.cos((math.pi*2)*(self.node.evalParm(f\"grad_c{i}\")*t +\n                                        self.node.evalParm(f\"grad_d{i}\")))\n                )\n            return tuple(color)\n\n        count = 20\n        basis, keys, values = [], [], []\n        lin = hou.rampBasis.Linear\n\n        for i in range(count):\n            frac = float(i)/float(count-1)\n            basis.append(lin)\n            keys.append(frac)\n            values.append(calc_val(frac))\n\n        ramp = hou.Ramp(basis, keys, values)\n        self.node.parm(\"sample_grad\").set(ramp)\n        self.reset_gradient_samples({\"script_multiparm_index\":-1})\n\n    def apply_cosine_preset(self) -&gt; None:\n        \"\"\"Apply a predefined cosine gradient preset.\n\n        Applies a preset gradient using cosine interpolation between colors, creating\n        smooth transitions between complementary colors.\n\n        Raises:\n            RuntimeError: If gradient preset cannot be applied\n            ValueError: If gradient parameters are invalid\n\n        Example:\n            &gt;&gt;&gt; manager = GradientManager.get_instance(node)\n            &gt;&gt;&gt; manager.apply_cosine_preset()  # Applies cosine gradient\n        \"\"\"\n        config_path = Path(__file__).parent.parent / \"config/gradients/gradient_presets.json\"\n        with open(config_path, encoding='utf-8') as f:\n            presets = json.load(f)\n\n        preset_name = self.node.parm(\"cosine_presets\").menuItems()[\n            self.node.parm(\"cosine_presets\").eval()\n        ]\n\n        if preset_name in presets:\n            preset = presets[preset_name]\n            for i, component in enumerate(['a', 'b', 'c', 'd']):\n                self.node.parmTuple(f\"grad_{component}\").set(preset[i])\n\n        self.create_cosine_gradient()\n        self.node.parm(\"cosine_presets\").set(0)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.__init__","title":"<code>__init__(node)</code>","text":"<p>Initialize with the node instance.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The Houdini node containing gradient parameters.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def __init__(self, node: hou.Node):\n    \"\"\"Initialize with the node instance.\n\n    Args:\n        node (hou.Node): The Houdini node containing gradient parameters.\n\n    Raises:\n        ValueError: If node is None or invalid.\n    \"\"\"\n    self.node = node\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.add_gradient_samples","title":"<code>add_gradient_samples()</code>","text":"<p>Add gradient samples to the main color list.</p> <p>Includes the option to delete samples from the gradient multiparm afterwards.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If sample addition fails.</p> <code>ValueError</code> <p>If color parameters are invalid.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def add_gradient_samples(self) -&gt; None:\n    \"\"\"Add gradient samples to the main color list.\n\n    Includes the option to delete samples from the gradient multiparm afterwards.\n\n    Raises:\n        RuntimeError: If sample addition fails.\n        ValueError: If color parameters are invalid.\n    \"\"\"\n    colors = self.node.parm(\"colors\")\n    tog_top = self.node.evalParm(\"tog_grad_top\")\n\n    for i in range(self.node.parm(\"grads\").eval()):\n        if self.node.parm(f\"tog_grad{i+1}\").eval():\n            color = self.node.parmTuple(f\"grad_rgb{i+1}\").eval()\n            iter = [colors.eval(), 0][tog_top]\n            colors.insertMultiParmInstance(iter)\n            self.node.parmTuple(f\"rgb{iter+1}\").set(color)\n            self.node.parm(f\"hex{iter+1}\").set(\n                colors.float_rgb_to_hex(float(color[0]), float(color[1]), float(color[2]))\n            )\n\n    if self.node.parm(\"tog_del_grad\").eval():\n        self.node.parm(\"grads\").set(0)\n\n    hou.ui.displayMessage(\"Colors successfully added to main list.\")\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.apply_cosine_preset","title":"<code>apply_cosine_preset()</code>","text":"<p>Apply a predefined cosine gradient preset.</p> <p>Applies a preset gradient using cosine interpolation between colors, creating smooth transitions between complementary colors.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If gradient preset cannot be applied</p> <code>ValueError</code> <p>If gradient parameters are invalid</p> Example <p>manager = GradientManager.get_instance(node) manager.apply_cosine_preset()  # Applies cosine gradient</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def apply_cosine_preset(self) -&gt; None:\n    \"\"\"Apply a predefined cosine gradient preset.\n\n    Applies a preset gradient using cosine interpolation between colors, creating\n    smooth transitions between complementary colors.\n\n    Raises:\n        RuntimeError: If gradient preset cannot be applied\n        ValueError: If gradient parameters are invalid\n\n    Example:\n        &gt;&gt;&gt; manager = GradientManager.get_instance(node)\n        &gt;&gt;&gt; manager.apply_cosine_preset()  # Applies cosine gradient\n    \"\"\"\n    config_path = Path(__file__).parent.parent / \"config/gradients/gradient_presets.json\"\n    with open(config_path, encoding='utf-8') as f:\n        presets = json.load(f)\n\n    preset_name = self.node.parm(\"cosine_presets\").menuItems()[\n        self.node.parm(\"cosine_presets\").eval()\n    ]\n\n    if preset_name in presets:\n        preset = presets[preset_name]\n        for i, component in enumerate(['a', 'b', 'c', 'd']):\n            self.node.parmTuple(f\"grad_{component}\").set(preset[i])\n\n    self.create_cosine_gradient()\n    self.node.parm(\"cosine_presets\").set(0)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.create_auto_samples","title":"<code>create_auto_samples()</code>","text":"<p>Create automatically spaced gradient samples.</p> <p>Creates evenly spaced samples along the gradient, optionally replacing existing samples.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If auto sample creation fails.</p> <code>ValueError</code> <p>If sample count is invalid.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def create_auto_samples(self) -&gt; None:\n    \"\"\"Create automatically spaced gradient samples.\n\n    Creates evenly spaced samples along the gradient, optionally replacing\n    existing samples.\n\n    Raises:\n        RuntimeError: If auto sample creation fails.\n        ValueError: If sample count is invalid.\n    \"\"\"\n    if self.node.parm(\"grads\").eval() &gt; 0:\n        if hou.ui.displayMessage(\"Replace gradient samples with automatically spaced ones?\",\n                               buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n    total = self.node.parm(\"grad_auto_sample\").eval()\n    samples = self.node.parm(\"grads\")\n    samples.set(0)\n\n    for i in range(total):\n        samples.insertMultiParmInstance(i)\n        frac = float(i)/float(total-1)\n        self.node.parm(f\"grad_pos{i+1}\").set(frac)\n        self.sample_gradient({\"script_multiparm_index\":-1}, i+1)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.create_cosine_gradient","title":"<code>create_cosine_gradient()</code>","text":"<p>Create a cosine-based color gradient.</p> <p>Generates a gradient using cosine functions with configurable parameters for each color channel.</p> Notes <ul> <li>Uses separate cosine functions for R, G, B channels</li> <li>Maintains smooth color transitions</li> <li>Automatically updates gradient samples</li> </ul> Example <p>manager.create_cosine_gradient()</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def create_cosine_gradient(self) -&gt; None:\n    \"\"\"Create a cosine-based color gradient.\n\n    Generates a gradient using cosine functions with configurable\n    parameters for each color channel.\n\n    Notes:\n        - Uses separate cosine functions for R, G, B channels\n        - Maintains smooth color transitions\n        - Automatically updates gradient samples\n\n    Example:\n        &gt;&gt;&gt; manager.create_cosine_gradient()\n    \"\"\"\n    def calc_val(t: float) -&gt; Tuple[float, float, float]:\n        color = []\n        for i in [\"r\", \"g\", \"b\"]:\n            color.append(\n                self.node.evalParm(f\"grad_a{i}\") +\n                self.node.evalParm(f\"grad_b{i}\") *\n                math.cos((math.pi*2)*(self.node.evalParm(f\"grad_c{i}\")*t +\n                                    self.node.evalParm(f\"grad_d{i}\")))\n            )\n        return tuple(color)\n\n    count = 20\n    basis, keys, values = [], [], []\n    lin = hou.rampBasis.Linear\n\n    for i in range(count):\n        frac = float(i)/float(count-1)\n        basis.append(lin)\n        keys.append(frac)\n        values.append(calc_val(frac))\n\n    ramp = hou.Ramp(basis, keys, values)\n    self.node.parm(\"sample_grad\").set(ramp)\n    self.reset_gradient_samples({\"script_multiparm_index\":-1})\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.get_instance","title":"<code>get_instance(node)</code>  <code>classmethod</code>","text":"<p>Get or create gradient manager instance for a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The Houdini node to manage gradients for.</p> required <p>Returns:</p> Name Type Description <code>GradientManager</code> <code>GradientManager</code> <p>Instance associated with the node.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If node is not a hou.Node instance.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>@classmethod\ndef get_instance(cls, node: hou.Node) -&gt; 'GradientManager':\n    \"\"\"Get or create gradient manager instance for a node.\n\n    Args:\n        node (hou.Node): The Houdini node to manage gradients for.\n\n    Returns:\n        GradientManager: Instance associated with the node.\n\n    Raises:\n        TypeError: If node is not a hou.Node instance.\n    \"\"\"\n    node_path = node.path()\n    if node_path not in cls._instances:\n        cls._instances[node_path] = cls(node)\n    return cls._instances[node_path]\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.reset_gradient_samples","title":"<code>reset_gradient_samples(kwargs)</code>","text":"<p>Reset colors on all gradient samples.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict</code> <p>Parameter kwargs from callback.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If gradient reset fails.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def reset_gradient_samples(self, kwargs: Dict) -&gt; None:\n    \"\"\"Reset colors on all gradient samples.\n\n    Args:\n        kwargs (Dict): Parameter kwargs from callback.\n\n    Raises:\n        RuntimeError: If gradient reset fails.\n    \"\"\"\n    for i in range(self.node.parm(\"grads\").eval()):\n        self.sample_gradient(kwargs, i+1)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.GradientManager.sample_gradient","title":"<code>sample_gradient(kwargs, index=-1)</code>","text":"<p>Sample a color from the defined gradient.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict</code> <p>Parameter kwargs from callback.</p> required <code>index</code> <code>int</code> <p>Specific index to sample. Defaults to -1 for current.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gradient parameters are invalid.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def sample_gradient(self, kwargs: Dict, index: int = -1) -&gt; None:\n    \"\"\"Sample a color from the defined gradient.\n\n    Args:\n        kwargs (Dict): Parameter kwargs from callback.\n        index (int, optional): Specific index to sample. Defaults to -1 for current.\n\n    Raises:\n        ValueError: If gradient parameters are invalid.\n    \"\"\"\n    ramp = self.node.parm(\"sample_grad\").eval()\n    i = kwargs['script_multiparm_index'] if index == -1 else index\n    parm = self.node.parm(f\"grad_pos{i}\").eval()\n    sample = ramp.lookup(parm)\n    self.node.parmTuple(f\"grad_rgb{i}\").set(sample)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.TextColorManager","title":"<code>TextColorManager</code>","text":"<p>Manages text-based color operations for the color palette configurator.</p> <p>A class that handles text input parsing and color extraction for the color palette configurator, supporting different text formats and gradient generation.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>Node</code> <p>The Houdini node containing text and color parameters</p> <code>_instances</code> <code>Dict[str, TextColorManager]</code> <p>Class-level dictionary of instances</p> <p>Methods:</p> Name Description <code>get_instance</code> <p>Get or create manager instance for a node</p> <code>extract_text_colors</code> <p>Parse text input for color values</p> <code>add_text_samples</code> <p>Add extracted colors to main palette</p> <code>add_text_gradient</code> <p>Create gradient from text colors</p> Example <p>node = hou.node('/obj/palette1') manager = TextColorManager.get_instance(node) manager.extract_text_colors()</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>class TextColorManager:\n    \"\"\"Manages text-based color operations for the color palette configurator.\n\n    A class that handles text input parsing and color extraction for the color palette\n    configurator, supporting different text formats and gradient generation.\n\n    Attributes:\n        node (hou.Node): The Houdini node containing text and color parameters\n        _instances (Dict[str, TextColorManager]): Class-level dictionary of instances\n\n    Methods:\n        get_instance: Get or create manager instance for a node\n        extract_text_colors: Parse text input for color values\n        add_text_samples: Add extracted colors to main palette\n        add_text_gradient: Create gradient from text colors\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/palette1')\n        &gt;&gt;&gt; manager = TextColorManager.get_instance(node)\n        &gt;&gt;&gt; manager.extract_text_colors()\n    \"\"\"\n    _instances: ClassVar[Dict[str, 'TextColorManager']] = {}\n\n    @classmethod\n    def get_instance(cls, node: hou.Node) -&gt; 'TextColorManager':\n        \"\"\"Get or create text color manager instance for a node.\n\n        Args:\n            node (hou.Node): The Houdini node to manage text colors for\n\n        Returns:\n            TextColorManager: Instance associated with the node\n\n        Raises:\n            TypeError: If node is not a hou.Node instance\n        \"\"\"\n        node_path = node.path()\n        if node_path not in cls._instances:\n            cls._instances[node_path] = cls(node)\n        return cls._instances[node_path]\n\n    def __init__(self, node: hou.Node):\n        self.node = node\n\n    def extract_text_colors(self, delete_lines: bool = False) -&gt; Tuple[int, List[str], str]:\n        \"\"\"Extract color values from text input.\n\n        Parses text input for hex color values in different formats based on mode.\n\n        Args:\n            delete_lines (bool, optional): Whether to remove color lines from text.\n                Defaults to False.\n\n        Returns:\n            Tuple[int, List[str], str]: Contains:\n                - Number of colors found\n                - List of extracted hex color values\n                - Updated text with colors optionally removed\n\n        Raises:\n            ValueError: If text input is invalid\n        \"\"\"\n        lines = self.node.evalParm(\"text\").splitlines()\n        mode = self.node.evalParm(\"text_mode\")\n        delete = self.node.evalParm(\"tog_del_text\")\n        colors = []\n        new_text = []\n        count = 0\n\n        for line in lines:\n            found = -1\n            # Hex color\n            if mode == 0 and (len(line) == 7 and line.startswith(\"#\") or len(line) == 6):\n                found = 1\n                color = line.replace(\"#\", \"\")\n            # Adobe CSS color\n            elif mode == 1 and line.find(\"hex { color:\") != -1:\n                found = line.find(\"hex { color:\") + 14\n                color = line[found:found + 6]\n\n            if found != -1 and len(color) == 6:\n                count += 1\n                colors.append(color)\n                if delete == 0 and delete_lines is True or delete_lines is False:\n                    new_text.append(line)\n            else:\n                new_text.append(line)\n\n        return count, colors, \"\\n\".join(new_text)\n\n    def add_text_samples(self) -&gt; None:\n        \"\"\"Add text-based colors to the main color list.\n\n        Extracts colors from text input and adds them to the main color parameter list,\n        with options for positioning and text cleanup.\n\n        Raises:\n            RuntimeError: If color addition fails\n        \"\"\"\n        if hou.ui.displayMessage(\"Add text-based colors to the main color list?\", buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n        top = self.node.evalParm(\"tog_text_top\")\n        delete = self.node.evalParm(\"tog_del_text\")\n        count, text_colors, new_text = self.extract_text_colors(delete_lines=True)\n        colors_parm = self.node.parm(\"colors\")\n\n        for color in text_colors:\n            iter = [colors_parm.eval(), 0][top]\n            colors_parm.insertMultiParmInstance(iter)\n            self.node.parmTuple(f\"rgb{iter+1}\").set(colors.hex_to_float_rgb(color))\n            self.node.parm(f\"hex{iter+1}\").set(color)\n\n        if count:\n            self.node.parm(\"text\").set(new_text)\n            hou.ui.displayMessage(f\"{count} colors added to the main color list.\")\n        else:\n            hou.ui.displayMessage(\"No colors found, no colors added.\")\n\n    def add_text_gradient(self) -&gt; None:\n        \"\"\"Create a gradient from text-based colors.\n\n        Creates a gradient ramp using colors extracted from text input,\n        with linear interpolation between colors.\n\n        Raises:\n            RuntimeError: If gradient creation fails\n            ValueError: If no valid colors found in text\n        \"\"\"\n        if hou.ui.displayMessage(\n                \"Create gradient from listed colors?\"+\n                \"\\nNote: does not delete them from this tab.\", buttons=(\"Yes\", \"No\")) == 1:\n            return\n\n        count, text_colors, _ = self.extract_text_colors(delete_lines=True)\n        if not count:\n            return\n\n        basis = [hou.rampBasis.Linear] * count\n        keys = [(float(1)/(count-1))*i for i in range(count)]\n        values = [colors.hex_to_float_rgb(color) for color in text_colors]\n\n        ramp = hou.Ramp(basis, keys, values)\n        self.node.parm(\"sample_grad\").set(ramp)\n        hou.ui.displayMessage(\"Check Gradient-Based tab for created gradient.\")\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.TextColorManager.add_text_gradient","title":"<code>add_text_gradient()</code>","text":"<p>Create a gradient from text-based colors.</p> <p>Creates a gradient ramp using colors extracted from text input, with linear interpolation between colors.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If gradient creation fails</p> <code>ValueError</code> <p>If no valid colors found in text</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def add_text_gradient(self) -&gt; None:\n    \"\"\"Create a gradient from text-based colors.\n\n    Creates a gradient ramp using colors extracted from text input,\n    with linear interpolation between colors.\n\n    Raises:\n        RuntimeError: If gradient creation fails\n        ValueError: If no valid colors found in text\n    \"\"\"\n    if hou.ui.displayMessage(\n            \"Create gradient from listed colors?\"+\n            \"\\nNote: does not delete them from this tab.\", buttons=(\"Yes\", \"No\")) == 1:\n        return\n\n    count, text_colors, _ = self.extract_text_colors(delete_lines=True)\n    if not count:\n        return\n\n    basis = [hou.rampBasis.Linear] * count\n    keys = [(float(1)/(count-1))*i for i in range(count)]\n    values = [colors.hex_to_float_rgb(color) for color in text_colors]\n\n    ramp = hou.Ramp(basis, keys, values)\n    self.node.parm(\"sample_grad\").set(ramp)\n    hou.ui.displayMessage(\"Check Gradient-Based tab for created gradient.\")\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.TextColorManager.add_text_samples","title":"<code>add_text_samples()</code>","text":"<p>Add text-based colors to the main color list.</p> <p>Extracts colors from text input and adds them to the main color parameter list, with options for positioning and text cleanup.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If color addition fails</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def add_text_samples(self) -&gt; None:\n    \"\"\"Add text-based colors to the main color list.\n\n    Extracts colors from text input and adds them to the main color parameter list,\n    with options for positioning and text cleanup.\n\n    Raises:\n        RuntimeError: If color addition fails\n    \"\"\"\n    if hou.ui.displayMessage(\"Add text-based colors to the main color list?\", buttons=(\"Yes\", \"No\")) == 1:\n        return\n\n    top = self.node.evalParm(\"tog_text_top\")\n    delete = self.node.evalParm(\"tog_del_text\")\n    count, text_colors, new_text = self.extract_text_colors(delete_lines=True)\n    colors_parm = self.node.parm(\"colors\")\n\n    for color in text_colors:\n        iter = [colors_parm.eval(), 0][top]\n        colors_parm.insertMultiParmInstance(iter)\n        self.node.parmTuple(f\"rgb{iter+1}\").set(colors.hex_to_float_rgb(color))\n        self.node.parm(f\"hex{iter+1}\").set(color)\n\n    if count:\n        self.node.parm(\"text\").set(new_text)\n        hou.ui.displayMessage(f\"{count} colors added to the main color list.\")\n    else:\n        hou.ui.displayMessage(\"No colors found, no colors added.\")\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.TextColorManager.extract_text_colors","title":"<code>extract_text_colors(delete_lines=False)</code>","text":"<p>Extract color values from text input.</p> <p>Parses text input for hex color values in different formats based on mode.</p> <p>Parameters:</p> Name Type Description Default <code>delete_lines</code> <code>bool</code> <p>Whether to remove color lines from text. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[int, List[str], str]</code> <p>Tuple[int, List[str], str]: Contains: - Number of colors found - List of extracted hex color values - Updated text with colors optionally removed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If text input is invalid</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def extract_text_colors(self, delete_lines: bool = False) -&gt; Tuple[int, List[str], str]:\n    \"\"\"Extract color values from text input.\n\n    Parses text input for hex color values in different formats based on mode.\n\n    Args:\n        delete_lines (bool, optional): Whether to remove color lines from text.\n            Defaults to False.\n\n    Returns:\n        Tuple[int, List[str], str]: Contains:\n            - Number of colors found\n            - List of extracted hex color values\n            - Updated text with colors optionally removed\n\n    Raises:\n        ValueError: If text input is invalid\n    \"\"\"\n    lines = self.node.evalParm(\"text\").splitlines()\n    mode = self.node.evalParm(\"text_mode\")\n    delete = self.node.evalParm(\"tog_del_text\")\n    colors = []\n    new_text = []\n    count = 0\n\n    for line in lines:\n        found = -1\n        # Hex color\n        if mode == 0 and (len(line) == 7 and line.startswith(\"#\") or len(line) == 6):\n            found = 1\n            color = line.replace(\"#\", \"\")\n        # Adobe CSS color\n        elif mode == 1 and line.find(\"hex { color:\") != -1:\n            found = line.find(\"hex { color:\") + 14\n            color = line[found:found + 6]\n\n        if found != -1 and len(color) == 6:\n            count += 1\n            colors.append(color)\n            if delete == 0 and delete_lines is True or delete_lines is False:\n                new_text.append(line)\n        else:\n            new_text.append(line)\n\n    return count, colors, \"\\n\".join(new_text)\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.TextColorManager.get_instance","title":"<code>get_instance(node)</code>  <code>classmethod</code>","text":"<p>Get or create text color manager instance for a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The Houdini node to manage text colors for</p> required <p>Returns:</p> Name Type Description <code>TextColorManager</code> <code>TextColorManager</code> <p>Instance associated with the node</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If node is not a hou.Node instance</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>@classmethod\ndef get_instance(cls, node: hou.Node) -&gt; 'TextColorManager':\n    \"\"\"Get or create text color manager instance for a node.\n\n    Args:\n        node (hou.Node): The Houdini node to manage text colors for\n\n    Returns:\n        TextColorManager: Instance associated with the node\n\n    Raises:\n        TypeError: If node is not a hou.Node instance\n    \"\"\"\n    node_path = node.path()\n    if node_path not in cls._instances:\n        cls._instances[node_path] = cls(node)\n    return cls._instances[node_path]\n</code></pre>"},{"location":"reference/nodes/color_palette_configurator/#nodes.color_palette_configurator.sample_screen_color","title":"<code>sample_screen_color(kwargs)</code>","text":"<p>Sample a color from the screen using a custom python state from SideFX Labs. The sampled color is applied to the parameter specified in the kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict</code> <p>Node callback kwargs dictionary containing 'parms' key    that specifies target parameters to receive the color value</p> required Note <p>This is a wrapper around screensampling.sample_ramp_color() that handles the parameter formatting required by the underlying function.</p> Source code in <code>nodes/color_palette_configurator.py</code> <pre><code>def sample_screen_color(kwargs: Dict) -&gt; None:\n    \"\"\"\n    Sample a color from the screen using a custom python state from SideFX Labs.\n    The sampled color is applied to the parameter specified in the kwargs.\n\n    Args:\n        kwargs: Node callback kwargs dictionary containing 'parms' key\n               that specifies target parameters to receive the color value\n\n    Note:\n        This is a wrapper around screensampling.sample_ramp_color() that\n        handles the parameter formatting required by the underlying function.\n    \"\"\"\n    screensampling.sample_ramp_color(kwargs[\"parms\"])\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/","title":"custom_node_shape_creator.py","text":"<p>Custom node shape creator for Houdini.</p> <p>This module provides functionality for creating and managing custom node shapes, including example network generation and shape data export. It handles:</p> <ul> <li>Creation of example node shape networks</li> <li>Export of shape data to JSON format</li> <li>Size and path management</li> <li>Group assignments and organization</li> </ul> <p>The module uses a class-based approach to maintain state and manage the creation process, with separate methods for different aspects of shape creation.</p> <p>Classes:</p> Name Description <code>CustomNodeShapeCreator</code> <p>Main shape creation functionality</p>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator","title":"<code>CustomNodeShapeCreator</code>","text":"<p>Manages creation and export of custom node shapes.</p> <p>This class handles the creation of example networks and export of node shape data to JSON format.</p> <p>Attributes:</p> Name Type Description <code>node</code> <p>The HDA node being managed</p> <code>builder</code> <p>NetworkBuilder instance for creating examples</p> Example <p>creator = CustomNodeShapeCreator(node) creator.create_example() creator.export_shape_data()</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>class CustomNodeShapeCreator:\n    \"\"\"Manages creation and export of custom node shapes.\n\n    This class handles the creation of example networks and export of node\n    shape data to JSON format.\n\n    Attributes:\n        node: The HDA node being managed\n        builder: NetworkBuilder instance for creating examples\n\n    Example:\n        &gt;&gt;&gt; creator = CustomNodeShapeCreator(node)\n        &gt;&gt;&gt; creator.create_example()\n        &gt;&gt;&gt; creator.export_shape_data()\n    \"\"\"\n\n    def __init__(self, node: hou.Node):\n        \"\"\"Initialize with the HDA node.\n\n        Args:\n            node (hou.Node): The HDA node containing custom shape parameters.\n                Must be a valid Digital Asset node.\n\n        Raises:\n            ValueError: If node is None or invalid\n            TypeError: If node is not of type hou.Node\n        \"\"\"\n        self.node = node\n        self.builder = NetworkBuilder(node.parent())\n\n    def create_example(self) -&gt; None:\n        \"\"\"Create an example node shape network.\n\n        Creates a complete network demonstrating shape creation techniques\n        based on the selected example type.\n\n        Notes:\n            - Resets node parameters before creation\n            - Handles different example types\n            - Creates appropriate network structure\n            - Sets up proper connections\n\n        Example:\n            &gt;&gt;&gt; creator.create_example()  # Creates based on node's example parameter\n\n        Raises:\n            ValueError: If example index is invalid\n        \"\"\"\n        example = self.node.evalParm(\"examples\")\n\n        if hou.ui.displayMessage(\n            \"Settings on this node will be overwritten when you create this example.\\n\"\n            \"Would you like to continue?\",\n            buttons=(\"Yes\", \"No\")\n        ) == 1:\n            return\n\n        # Reset node parameters\n        for parm in self.node.parms():\n            try:\n                parm.revertToDefaults()\n            except hou.PermissionError:\n                continue\n\n        # Map example index to template name\n        templates = {\n            0: \"simple_clip_method\",\n            1: \"complex_constructed_method\",\n            2: \"honeycomb_trace_method\"\n        }\n\n        template_name = templates.get(example)\n        if not template_name:\n            raise ValueError(f\"Invalid example index: {example}\")\n\n        # Build network from template\n        self.builder.build_from_template(template_name)\n        self.update_path()\n        self.update_size()\n\n    def export_shape_data(self) -&gt; None:\n        \"\"\"Export node shape data to JSON file.\n\n        Extracts shape data from the current node setup and exports it\n        in a format suitable for node shape definition.\n\n        Notes:\n            - Validates shape name and path\n            - Generates shape data structure\n            - Handles outline, flags, inputs/outputs\n            - Creates proper JSON formatting\n\n        Example:\n            &gt;&gt;&gt; creator.export_shape_data()\n\n        Raises:\n            ValidationError: If shape name not specified\n        \"\"\"\n        def gen_list(attrib_name: str) -&gt; list:\n            \"\"\"Generate list of point values from geometry attribute.\"\"\"\n            return [\n                [float(x.strip()) for x in i.split(\",\")]\n                for i in geo.stringListAttribValue(attrib_name)\n            ]\n\n        # Update path and validate\n        self.update_path()\n        path = Path(self.node.evalParm(\"path\"))\n        name = self.node.evalParm(\"shape_name\")\n\n        if not name:\n            raise ValidationError(\"No shape name specified\")\n\n        # Generate shape data\n        geo = self.node.node(\"JSON_OUT\").geometry()\n        data = {\n            \"name\": name,\n            \"flags\": {\n                str(i): {\"outline\": gen_list(f\"flag{i}_outline\")}\n                for i in range(4)\n            },\n            \"outline\": gen_list(\"outline\"),\n            \"inputs\": gen_list(\"inputs\"),\n            \"outputs\": gen_list(\"outputs\"),\n            \"icon\": gen_list(\"icon\")\n        }\n\n        # Write data\n        if write_json(path, data):\n            hou.ui.displayMessage(\n                f\"Successfully wrote the '{name}' node shape to\\n{path}\"\n            )\n\n    def update_path(self) -&gt; None:\n        \"\"\"Update the export path parameter and label.\n\n        Updates the path parameter with the full normalized path and creates a\n        truncated version for the display label if path is too long.\n\n        Raises:\n            RuntimeError: If path parameters cannot be updated\n            ValueError: If directory or shape name is invalid\n        \"\"\"\n        path_str = f'{self.node.evalParm(\"dir\")}/{self.node.evalParm(\"shape_name\")}.json'\n        path_str = hou.text.normpath(hou.text.expandString(path_str))\n\n        self.node.parm(\"path\").set(path_str)\n\n        # Truncate long paths in label\n        if len(path_str) &gt; 65:\n            path_str = path_str[:25] + \".....\" + path_str[-45:]\n        self.node.parm(\"lbl_path\").set(path_str)\n\n    def update_size(self) -&gt; None:\n        \"\"\"Update the node shape size parameter and label.\n\n        Updates the size parameter based on current width/height settings and\n        refreshes the size display label.\n\n        Raises:\n            RuntimeError: If size parameters cannot be updated\n            ValueError: If width or height values are invalid\n        \"\"\"\n        if self.node.input(0):\n            bounds = self.node.node(\"Set_groups_colors\").geometry().boundingBox().sizevec()\n            bounds = (round(bounds[0], 2), round(bounds[1], 2))\n\n            self.node.parm(\"lbl_size\").set(f\"{bounds[0]} x {bounds[1]}\")\n\n            if self.node.evalParm(\"restrict_to_shape\"):\n                self.node.parm(\"icon_scale\").set(\n                    min(bounds[0], bounds[1], self.node.evalParm(\"icon_scale\"))\n                )\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator.__init__","title":"<code>__init__(node)</code>","text":"<p>Initialize with the HDA node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The HDA node containing custom shape parameters. Must be a valid Digital Asset node.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid</p> <code>TypeError</code> <p>If node is not of type hou.Node</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def __init__(self, node: hou.Node):\n    \"\"\"Initialize with the HDA node.\n\n    Args:\n        node (hou.Node): The HDA node containing custom shape parameters.\n            Must be a valid Digital Asset node.\n\n    Raises:\n        ValueError: If node is None or invalid\n        TypeError: If node is not of type hou.Node\n    \"\"\"\n    self.node = node\n    self.builder = NetworkBuilder(node.parent())\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator.create_example","title":"<code>create_example()</code>","text":"<p>Create an example node shape network.</p> <p>Creates a complete network demonstrating shape creation techniques based on the selected example type.</p> Notes <ul> <li>Resets node parameters before creation</li> <li>Handles different example types</li> <li>Creates appropriate network structure</li> <li>Sets up proper connections</li> </ul> Example <p>creator.create_example()  # Creates based on node's example parameter</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If example index is invalid</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def create_example(self) -&gt; None:\n    \"\"\"Create an example node shape network.\n\n    Creates a complete network demonstrating shape creation techniques\n    based on the selected example type.\n\n    Notes:\n        - Resets node parameters before creation\n        - Handles different example types\n        - Creates appropriate network structure\n        - Sets up proper connections\n\n    Example:\n        &gt;&gt;&gt; creator.create_example()  # Creates based on node's example parameter\n\n    Raises:\n        ValueError: If example index is invalid\n    \"\"\"\n    example = self.node.evalParm(\"examples\")\n\n    if hou.ui.displayMessage(\n        \"Settings on this node will be overwritten when you create this example.\\n\"\n        \"Would you like to continue?\",\n        buttons=(\"Yes\", \"No\")\n    ) == 1:\n        return\n\n    # Reset node parameters\n    for parm in self.node.parms():\n        try:\n            parm.revertToDefaults()\n        except hou.PermissionError:\n            continue\n\n    # Map example index to template name\n    templates = {\n        0: \"simple_clip_method\",\n        1: \"complex_constructed_method\",\n        2: \"honeycomb_trace_method\"\n    }\n\n    template_name = templates.get(example)\n    if not template_name:\n        raise ValueError(f\"Invalid example index: {example}\")\n\n    # Build network from template\n    self.builder.build_from_template(template_name)\n    self.update_path()\n    self.update_size()\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator.export_shape_data","title":"<code>export_shape_data()</code>","text":"<p>Export node shape data to JSON file.</p> <p>Extracts shape data from the current node setup and exports it in a format suitable for node shape definition.</p> Notes <ul> <li>Validates shape name and path</li> <li>Generates shape data structure</li> <li>Handles outline, flags, inputs/outputs</li> <li>Creates proper JSON formatting</li> </ul> Example <p>creator.export_shape_data()</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If shape name not specified</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def export_shape_data(self) -&gt; None:\n    \"\"\"Export node shape data to JSON file.\n\n    Extracts shape data from the current node setup and exports it\n    in a format suitable for node shape definition.\n\n    Notes:\n        - Validates shape name and path\n        - Generates shape data structure\n        - Handles outline, flags, inputs/outputs\n        - Creates proper JSON formatting\n\n    Example:\n        &gt;&gt;&gt; creator.export_shape_data()\n\n    Raises:\n        ValidationError: If shape name not specified\n    \"\"\"\n    def gen_list(attrib_name: str) -&gt; list:\n        \"\"\"Generate list of point values from geometry attribute.\"\"\"\n        return [\n            [float(x.strip()) for x in i.split(\",\")]\n            for i in geo.stringListAttribValue(attrib_name)\n        ]\n\n    # Update path and validate\n    self.update_path()\n    path = Path(self.node.evalParm(\"path\"))\n    name = self.node.evalParm(\"shape_name\")\n\n    if not name:\n        raise ValidationError(\"No shape name specified\")\n\n    # Generate shape data\n    geo = self.node.node(\"JSON_OUT\").geometry()\n    data = {\n        \"name\": name,\n        \"flags\": {\n            str(i): {\"outline\": gen_list(f\"flag{i}_outline\")}\n            for i in range(4)\n        },\n        \"outline\": gen_list(\"outline\"),\n        \"inputs\": gen_list(\"inputs\"),\n        \"outputs\": gen_list(\"outputs\"),\n        \"icon\": gen_list(\"icon\")\n    }\n\n    # Write data\n    if write_json(path, data):\n        hou.ui.displayMessage(\n            f\"Successfully wrote the '{name}' node shape to\\n{path}\"\n        )\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator.update_path","title":"<code>update_path()</code>","text":"<p>Update the export path parameter and label.</p> <p>Updates the path parameter with the full normalized path and creates a truncated version for the display label if path is too long.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If path parameters cannot be updated</p> <code>ValueError</code> <p>If directory or shape name is invalid</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def update_path(self) -&gt; None:\n    \"\"\"Update the export path parameter and label.\n\n    Updates the path parameter with the full normalized path and creates a\n    truncated version for the display label if path is too long.\n\n    Raises:\n        RuntimeError: If path parameters cannot be updated\n        ValueError: If directory or shape name is invalid\n    \"\"\"\n    path_str = f'{self.node.evalParm(\"dir\")}/{self.node.evalParm(\"shape_name\")}.json'\n    path_str = hou.text.normpath(hou.text.expandString(path_str))\n\n    self.node.parm(\"path\").set(path_str)\n\n    # Truncate long paths in label\n    if len(path_str) &gt; 65:\n        path_str = path_str[:25] + \".....\" + path_str[-45:]\n    self.node.parm(\"lbl_path\").set(path_str)\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.CustomNodeShapeCreator.update_size","title":"<code>update_size()</code>","text":"<p>Update the node shape size parameter and label.</p> <p>Updates the size parameter based on current width/height settings and refreshes the size display label.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If size parameters cannot be updated</p> <code>ValueError</code> <p>If width or height values are invalid</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def update_size(self) -&gt; None:\n    \"\"\"Update the node shape size parameter and label.\n\n    Updates the size parameter based on current width/height settings and\n    refreshes the size display label.\n\n    Raises:\n        RuntimeError: If size parameters cannot be updated\n        ValueError: If width or height values are invalid\n    \"\"\"\n    if self.node.input(0):\n        bounds = self.node.node(\"Set_groups_colors\").geometry().boundingBox().sizevec()\n        bounds = (round(bounds[0], 2), round(bounds[1], 2))\n\n        self.node.parm(\"lbl_size\").set(f\"{bounds[0]} x {bounds[1]}\")\n\n        if self.node.evalParm(\"restrict_to_shape\"):\n            self.node.parm(\"icon_scale\").set(\n                min(bounds[0], bounds[1], self.node.evalParm(\"icon_scale\"))\n            )\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.match_start","title":"<code>match_start(kwargs)</code>","text":"<p>Match the curve end parameter to the start parameter.</p> <p>Synchronizes the end parameter value based on the start parameter when matching is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Callback keyword arguments containing: - node: The HDA node instance - parm: The parameter being modified - parm_name: Name of the parameter</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required kwargs are missing</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def match_start(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Match the curve end parameter to the start parameter.\n\n    Synchronizes the end parameter value based on the start parameter when\n    matching is enabled.\n\n    Args:\n        kwargs (Dict[str, Any]): Callback keyword arguments containing:\n            - node: The HDA node instance\n            - parm: The parameter being modified\n            - parm_name: Name of the parameter\n\n    Returns:\n        None\n\n    Raises:\n        KeyError: If required kwargs are missing\n    \"\"\"\n    node = kwargs[\"node\"]\n    curve_start = kwargs[\"parm\"]\n    curve_end = node.parm(kwargs[\"parm_name\"].replace(\"start\", \"end\"))\n    match_toggle = node.parm(kwargs[\"parm_name\"].replace(\"start\", \"end_match\"))\n\n    if match_toggle.eval():\n        curve_end.set(1 - curve_start.eval())\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.on_example_create","title":"<code>on_example_create(kwargs)</code>","text":"<p>Create an example node shape network.</p> <p>Creates a demonstration network showing custom node shape usage.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Callback keyword arguments containing: - node: The HDA node instance</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If example creation fails</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def on_example_create(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Create an example node shape network.\n\n    Creates a demonstration network showing custom node shape usage.\n\n    Args:\n        kwargs (Dict[str, Any]): Callback keyword arguments containing:\n            - node: The HDA node instance\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If example creation fails\n    \"\"\"\n    creator = CustomNodeShapeCreator(kwargs[\"node\"])\n    creator.create_example()\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.on_export_shape","title":"<code>on_export_shape(kwargs)</code>","text":"<p>Export node shape data to JSON.</p> <p>Saves the current node shape configuration to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Callback keyword arguments containing: - node: The HDA node instance</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If export fails</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def on_export_shape(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Export node shape data to JSON.\n\n    Saves the current node shape configuration to a JSON file.\n\n    Args:\n        kwargs (Dict[str, Any]): Callback keyword arguments containing:\n            - node: The HDA node instance\n\n    Returns:\n        None\n\n    Raises:\n        IOError: If export fails\n    \"\"\"\n    creator = CustomNodeShapeCreator(kwargs[\"node\"])\n    creator.export_shape_data()\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.on_update_path","title":"<code>on_update_path(kwargs)</code>","text":"<p>Update the export path parameter.</p> <p>Updates the path parameter and display label based on current settings.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Callback keyword arguments containing: - node: The HDA node instance</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If path update fails</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def on_update_path(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Update the export path parameter.\n\n    Updates the path parameter and display label based on current settings.\n\n    Args:\n        kwargs (Dict[str, Any]): Callback keyword arguments containing:\n            - node: The HDA node instance\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If path update fails\n    \"\"\"\n    creator = CustomNodeShapeCreator(kwargs[\"node\"])\n    creator.update_path()\n</code></pre>"},{"location":"reference/nodes/custom_node_shape_creator/#nodes.custom_node_shape_creator.on_update_size","title":"<code>on_update_size(kwargs)</code>","text":"<p>Update the node shape size parameter.</p> <p>Updates size parameter and display label based on current dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Callback keyword arguments containing: - node: The HDA node instance</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If size update fails</p> Source code in <code>nodes/custom_node_shape_creator.py</code> <pre><code>def on_update_size(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Update the node shape size parameter.\n\n    Updates size parameter and display label based on current dimensions.\n\n    Args:\n        kwargs (Dict[str, Any]): Callback keyword arguments containing:\n            - node: The HDA node instance\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If size update fails\n    \"\"\"\n    creator = CustomNodeShapeCreator(kwargs[\"node\"])\n    creator.update_size()\n</code></pre>"},{"location":"reference/nodes/inspect_node_shape_file/","title":"inspect_node_shape_file.py","text":"<p>Utility functions for inspecting and loading Houdini node shape files.</p> <p>This module provides functionality to read, parse, and apply node shape data from JSON files. It handles:</p> <ul> <li>Loading shape files</li> <li>Applying shape data to nodes</li> <li>Generating shape statistics</li> <li>Parameter management</li> </ul> <p>Functions:</p> Name Description <code>clear_parameters</code> <p>Reset shape parameters</p> <code>generate_statistics</code> <p>Calculate shape bounds</p> <code>fill_node_shape_parameters</code> <p>Apply shape data to node</p>"},{"location":"reference/nodes/inspect_node_shape_file/#nodes.inspect_node_shape_file.clear_parameters","title":"<code>clear_parameters(kwargs)</code>","text":"<p>Clear node shape parameters to default values.</p> <p>Resets all node shape parameters back to their original default values, including size, path, and curve parameters.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Node callback kwargs containing: - node: The HDA node instance whose parameters should be cleared</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required kwargs are missing</p> <code>RuntimeError</code> <p>If parameters cannot be reset</p> Example <p>on_clear_parameters({'node': hou.node('/obj/myHDA')})</p> Source code in <code>nodes/inspect_node_shape_file.py</code> <pre><code>def clear_parameters(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Clear node shape parameters to default values.\n\n    Resets all node shape parameters back to their original default values,\n    including size, path, and curve parameters.\n\n    Args:\n        kwargs (Dict[str, Any]): Node callback kwargs containing:\n            - node: The HDA node instance whose parameters should be cleared\n\n    Returns:\n        None\n\n    Raises:\n        KeyError: If required kwargs are missing\n        RuntimeError: If parameters cannot be reset\n\n    Example:\n        &gt;&gt;&gt; on_clear_parameters({'node': hou.node('/obj/myHDA')})\n    \"\"\"\n    node = kwargs[\"node\"]\n    for parm_name in [\"mparm_outline\", \"mparm_inputs\", \"mparm_outputs\"]:\n        node.parm(parm_name).set(0)\n\n    for i in range(4):\n        node.parm(f\"mparm_flag{i}\").set(0)\n\n    node.parmTuple(\"icon_min\").set((0, 0))\n    node.parmTuple(\"icon_max\").set((0, 0))\n</code></pre>"},{"location":"reference/nodes/inspect_node_shape_file/#nodes.inspect_node_shape_file.fill_node_shape_parameters","title":"<code>fill_node_shape_parameters(kwargs)</code>","text":"<p>Fill node parameters based on JSON shape file contents.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Node callback kwargs containing target node</p> required Notes <ul> <li>Clears existing parameters first</li> <li>Handles flags, outline, inputs/outputs</li> <li>Sets proper node name and comment</li> <li>Maintains proper parameter organization</li> <li>Updates statistics after loading</li> </ul> Example <p>fill_node_shape_parameters({\"node\": node})</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape file is invalid or missing required data</p> Source code in <code>nodes/inspect_node_shape_file.py</code> <pre><code>def fill_node_shape_parameters(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Fill node parameters based on JSON shape file contents.\n\n    Args:\n        kwargs: Node callback kwargs containing target node\n\n    Notes:\n        - Clears existing parameters first\n        - Handles flags, outline, inputs/outputs\n        - Sets proper node name and comment\n        - Maintains proper parameter organization\n        - Updates statistics after loading\n\n    Example:\n        &gt;&gt;&gt; fill_node_shape_parameters({\"node\": node})\n\n    Raises:\n        ValueError: If shape file is invalid or missing required data\n    \"\"\"\n    node = kwargs[\"node\"]\n    data = read_json(node.evalParm(\"file\"))\n    if not data:\n        return\n\n    clear_parameters(kwargs)\n\n    for key, value in data.items():\n        if key == \"name\":\n            node.setComment(f\"Loaded: {value}\")\n            node.setGenericFlag(hou.nodeFlag.DisplayComment, True)\n\n        elif key == \"flags\":\n            for num, flag_data in value.items():\n                node.parm(f\"mparm_flag{num}\").set(len(flag_data[\"outline\"]))\n                for i, pos in enumerate(flag_data[\"outline\"]):\n                    node.parmTuple(f\"flag{num}_pos{i}\").set(pos)\n\n        elif key == \"outline\":\n            node.parm(\"mparm_outline\").set(len(value))\n            for i, pos in enumerate(value):\n                node.parmTuple(f\"outline_pos{i}\").set(pos)\n\n        elif key in [\"inputs\", \"outputs\"]:\n            node.parm(f\"mparm_{key}\").set(len(value))\n            for i, pos in enumerate(value):\n                node.parmTuple(f\"{key}_pos{i}\").set((pos[0], pos[1]))\n                node.parm(f\"{key}_angle{i}\").set(pos[2])\n\n        elif key == \"icon\":\n            node.parmTuple(\"icon_min\").set(value[0])\n            node.parmTuple(\"icon_max\").set(value[1])\n\n    generate_statistics(kwargs)\n</code></pre>"},{"location":"reference/nodes/inspect_node_shape_file/#nodes.inspect_node_shape_file.generate_statistics","title":"<code>generate_statistics(kwargs)</code>","text":"<p>Calculate and display shape element bounds statistics.</p> <p>Analyzes the geometric bounds of various shape elements and updates label parameters with the information.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Node callback kwargs containing node to analyze</p> required Notes <ul> <li>Calculates bounds for shapes, inputs/outputs, icons</li> <li>Updates label parameters with formatted information</li> <li>Uses node's digit precision setting</li> <li>Handles different geometry types appropriately</li> </ul> Example <p>generate_statistics({\"node\": shape_node})</p> Source code in <code>nodes/inspect_node_shape_file.py</code> <pre><code>def generate_statistics(kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Calculate and display shape element bounds statistics.\n\n    Analyzes the geometric bounds of various shape elements and updates\n    label parameters with the information.\n\n    Args:\n        kwargs: Node callback kwargs containing node to analyze\n\n    Notes:\n        - Calculates bounds for shapes, inputs/outputs, icons\n        - Updates label parameters with formatted information\n        - Uses node's digit precision setting\n        - Handles different geometry types appropriately\n\n    Example:\n        &gt;&gt;&gt; generate_statistics({\"node\": shape_node})\n    \"\"\"\n    node = kwargs[\"node\"]\n    digits = node.evalParm(\"digits\")\n    geometries = {\n        \"lbl_shape\": node.node(\"COMBINED_SHAPES\").geometry(),\n        \"lbl_inout\": node.node(\"COMBINED_INOUT\").geometry(),\n        \"lbl_icon\": node.node(\"ICON\").geometry(),\n        \"lbl_overall\": node.node(\"OVERALL\").geometry()\n    }\n\n    for lbl_name, geo in geometries.items():\n        bbox = geo.boundingBox()\n        min_vec = bbox.minvec()\n        max_vec = bbox.maxvec()\n        size_vec = bbox.sizevec()\n        center = bbox.center()\n\n        stats = (\n            f\"X: {round(min_vec[0], digits)} to {round(max_vec[0], digits)}  |  \"\n            f\"Y: {round(min_vec[1], digits)} to {round(max_vec[1], digits)}  |  \"\n            f\"Size: {round(size_vec[0], digits)} x {round(size_vec[1], digits)}  |  \"\n            f\"Center: {round(center[0], digits)} x {round(center[1], digits)}\"\n        )\n        node.parm(lbl_name).set(stats)\n</code></pre>"},{"location":"reference/stringweaver/stringweaver/","title":"stringweaver.py","text":""},{"location":"reference/stringweaver/providers/base/","title":"base.py","text":""},{"location":"reference/stringweaver/providers/nodes/","title":"nodes.py","text":""},{"location":"reference/stringweaver/providers/parameters/","title":"parameters.py","text":""},{"location":"reference/stringweaver/services/cache/","title":"cache.py","text":""},{"location":"reference/stringweaver/services/history/","title":"history.py","text":""},{"location":"reference/stringweaver/widgets/options/","title":"options.py","text":""},{"location":"reference/stringweaver/widgets/results/","title":"results.py","text":""},{"location":"reference/stringweaver/widgets/search/","title":"search.py","text":""},{"location":"reference/utils/action_buttons/","title":"action_buttons.py","text":"<p>Utility functions for Houdini action button callbacks.</p> <p>This module provides functions commonly used in action button callbacks, particularly focusing on file and path operations. It handles:</p> <ul> <li>Path opening and validation</li> <li>Directory creation</li> <li>File browser integration</li> <li>Path expansion and normalization</li> </ul>"},{"location":"reference/utils/action_buttons/#utils.action_buttons.open_path","title":"<code>open_path(kwargs, parm_name, path_instead=False)</code>","text":"<p>Open a path in the system file browser.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Node callback dictionary</p> required <code>parm_name</code> <code>Union[str, Parm]</code> <p>Parameter name or parameter containing path</p> required <code>path_instead</code> <code>bool</code> <p>Whether to use parm_name as direct path</p> <code>False</code> Notes <ul> <li>Handles both parameters and direct paths</li> <li>Creates directories if needed</li> <li>Validates paths before opening</li> <li>Handles both files and directories</li> <li>Expands Houdini variables</li> </ul> Example <p>Since: 1.0.0</p> Source code in <code>utils/action_buttons.py</code> <pre><code>def open_path(kwargs: Dict[str, Any], parm_name: Union[str, hou.Parm],\n              path_instead: bool = False) -&gt; None:\n    \"\"\"Open a path in the system file browser.\n\n    Args:\n        kwargs: Node callback dictionary\n        parm_name: Parameter name or parameter containing path\n        path_instead: Whether to use parm_name as direct path\n\n    Notes:\n        - Handles both parameters and direct paths\n        - Creates directories if needed\n        - Validates paths before opening\n        - Handles both files and directories\n        - Expands Houdini variables\n\n    Example:\n        &gt;&gt;&gt; # From parameter\n        &gt;&gt;&gt; open_path(kwargs, \"file_path\")\n\n        &gt;&gt;&gt; # Direct path\n        &gt;&gt;&gt; open_path(kwargs, \"/path/to/file\", path_instead=True)\n\n    Since: 1.0.0\n    \"\"\"\n    if path_instead:\n        dir_path = parm_name\n    else:\n        if isinstance(parm_name, str):\n            dir_path = kwargs['node'].evalParm(parm_name)\n        elif isinstance(parm_name, hou.Parm):\n            template = parm_name.parmTemplate()\n            if template.type() == hou.parmTemplateType.String:\n                dir_path = parm_name.eval()\n            else:\n                hou.ui.displayMessage(\n                    \"The supplied parm is not a string type.\")\n                return\n        else:\n            hou.ui.displayMessage(text=f\"Invalid parm name supplied: {parm_name}. Action cancelled.\",\n                                    severity=hou.severityType.ImportantMessage)\n            return\n    dir_path = hou.text.expandString(dir_path)\n\n    if dir_path != \"\":\n        # If the directory exists, check if it is a file or folder and open it in the file browser.\n        dir_path = Path(dir_path)\n        if dir_path.exists():\n            if dir_path.is_dir() is False:\n                dir_path = dir_path.parent\n            if str(dir_path)[-1] != '/':\n                dir_path = str(dir_path) + '/'\n            hou.ui.showInFileBrowser(dir_path)\n            return\n        else:\n            # If the directory doesn't exist, check if it's a file in a second way.\n            if dir_path.name != dir_path.stem:\n                dir_path = dir_path.parent\n                if dir_path.exists():\n                    if str(dir_path)[-1] != '/':\n                        dir_path = str(dir_path) + '/'\n                    hou.ui.showInFileBrowser(dir_path)\n                    return\n            # Check if the directory even appears to be a path.\n            if str(dir_path).find(\"/\") &lt; 0 and str(dir_path).find(\"\\\\\") &lt; 0:\n                hou.ui.displayMessage(text=f\"Invalid path supplied: {dir_path}. Action cancelled.\",\n                                        severity=hou.severityType.ImportantMessage)\n                return\n            # If the directory doesn't exist, ask if the user wants to create it.\n            if hou.ui.displayMessage(\n                    f\"The following directory does not exist, would you like to create it?\\n{dir_path}\",\n                    (\"Yes\", \"No\")) == 0:\n                dir_path.mkdir(parents=True, exist_ok=True)\n                hou.ui.showInFileBrowser(str(dir_path))\n                return\n    else:\n        hou.ui.displayMessage(text=\"Directory not defined, could not open.\",\n                                severity=hou.severityType.ImportantMessage)\n</code></pre>"},{"location":"reference/utils/action_buttons/#utils.action_buttons.open_path--from-parameter","title":"From parameter","text":"<p>open_path(kwargs, \"file_path\")</p>"},{"location":"reference/utils/action_buttons/#utils.action_buttons.open_path--direct-path","title":"Direct path","text":"<p>open_path(kwargs, \"/path/to/file\", path_instead=True)</p>"},{"location":"reference/utils/colors/","title":"colors.py","text":"<p>Color manipulation and conversion utilities for Houdini.</p> <p>This module provides functions for converting between different color formats and managing node color palettes within Houdini. It handles hex colors, RGB floats, and Houdini's native color representations.</p> <p>Functions:</p> Name Description <code>hex_to_float_rgb</code> <p>Convert hex color strings to RGB float values</p> <code>float_rgb_to_hex</code> <p>Convert RGB float values to hex color strings</p> <code>color_selected_nodes</code> <p>Apply colors to selected nodes</p> <code>validate_palette_file</code> <p>Validate Houdini color palette files</p> <code>load_default_palette</code> <p>Get Houdini's default color palette</p>"},{"location":"reference/utils/colors/#utils.colors.color_selected_nodes","title":"<code>color_selected_nodes(node)</code>","text":"<p>Changes the color of the selected nodes with a color palette window.</p> <p>Opens a color picker dialog and applies the chosen color to selected nodes and an optional target node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Optional[Node]</code> <p>Additional node to apply color to besides selection. If None, only selected nodes will be colored.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If color application fails</p> <code>ValueError</code> <p>If node is invalid</p> Example <p>change_node_color(hou.node('/obj/geo1'))  # Colors geo1 and selection</p> Source code in <code>utils/colors.py</code> <pre><code>def color_selected_nodes(node:hou.Node) -&gt; None:\n    \"\"\"Changes the color of the selected nodes with a color palette window.\n\n    Opens a color picker dialog and applies the chosen color to selected nodes\n    and an optional target node.\n\n    Args:\n        node (Optional[hou.Node]): Additional node to apply color to besides selection.\n            If None, only selected nodes will be colored.\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If color application fails\n        ValueError: If node is invalid\n\n    Example:\n        &gt;&gt;&gt; change_node_color(hou.node('/obj/geo1'))  # Colors geo1 and selection\n    \"\"\"\n    sel = list(hou.selectedNodes())+[node]\n    color = (None, sel[0].color())[len(sel) &gt; 0]\n    color = hou.ui.selectColor(color)\n    if len(sel) &gt; 0 and color != None:\n        print(f\"The picked color is {color}\\nNote: You need to disable the 'Color Correction' flag in the color picker (ramp in the top right) for the colors to be accurate.\")\n        for sel_node in sel:\n            sel_node.setColor(color)\n</code></pre>"},{"location":"reference/utils/colors/#utils.colors.float_rgb_to_hex","title":"<code>float_rgb_to_hex(red, green, blue)</code>","text":"<p>Convert RGB float values to hex color string.</p> <p>Parameters:</p> Name Type Description Default <code>red</code> <code>float</code> <p>Red value (0-1)</p> required <code>green</code> <code>float</code> <p>Green value (0-1)</p> required <code>blue</code> <code>float</code> <p>Blue value (0-1)</p> required <p>Returns:</p> Type Description <code>str</code> <p>6-character hex color string without # prefix</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; float_rgb_to_hex(1.0, 0.0, 0.0)\n'ff0000'\n&gt;&gt;&gt; float_rgb_to_hex(0.0, 1.0, 0.0)\n'00ff00'\n</code></pre> Source code in <code>utils/colors.py</code> <pre><code>def float_rgb_to_hex(red: float, green: float, blue: float) -&gt; str:\n    \"\"\"Convert RGB float values to hex color string.\n\n    Args:\n        red: Red value (0-1)\n        green: Green value (0-1)\n        blue: Blue value (0-1)\n\n    Returns:\n        6-character hex color string without # prefix\n\n    Examples:\n        &gt;&gt;&gt; float_rgb_to_hex(1.0, 0.0, 0.0)\n        'ff0000'\n        &gt;&gt;&gt; float_rgb_to_hex(0.0, 1.0, 0.0)\n        '00ff00'\n    \"\"\"\n    red = int(red * 255)\n    green = int(green * 255)\n    blue = int(blue * 255)\n    return f\"{red:02x}{green:02x}{blue:02x}\"\n</code></pre>"},{"location":"reference/utils/colors/#utils.colors.hex_to_float_rgb","title":"<code>hex_to_float_rgb(hex_value)</code>","text":"<p>Convert a hex color string to RGB float values.</p> <p>Parameters:</p> Name Type Description Default <code>hex_value</code> <code>str</code> <p>Hex color string (e.g. \"FF0000\" or \"#FF0000\")</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple of RGB float values from 0-1</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hex_to_float_rgb(\"#FF0000\")\n(1.0, 0.0, 0.0)\n&gt;&gt;&gt; hex_to_float_rgb(\"00FF00\")\n(0.0, 1.0, 0.0)\n</code></pre> Source code in <code>utils/colors.py</code> <pre><code>def hex_to_float_rgb(hex_value: str) -&gt; Tuple[float, float, float]:\n    \"\"\"Convert a hex color string to RGB float values.\n\n    Args:\n        hex_value: Hex color string (e.g. \"FF0000\" or \"#FF0000\")\n\n    Returns:\n        Tuple of RGB float values from 0-1\n\n    Examples:\n        &gt;&gt;&gt; hex_to_float_rgb(\"#FF0000\")\n        (1.0, 0.0, 0.0)\n        &gt;&gt;&gt; hex_to_float_rgb(\"00FF00\")\n        (0.0, 1.0, 0.0)\n    \"\"\"\n    hex_value = hex_value.lstrip(\"#\")\n    lv = len(hex_value)\n    rgb = tuple(int(hex_value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n    return tuple(float(i)/256 for i in rgb)\n</code></pre>"},{"location":"reference/utils/colors/#utils.colors.load_default_palette","title":"<code>load_default_palette()</code>","text":"<p>Get Houdini's default 36 color palette.</p> <p>Returns:</p> Type Description <code>List[Tuple[float, float, float]]</code> <p>List of RGB float tuples representing default colors</p> Note <p>The default palette includes white, black, grays, and various hues. Colors are returned as RGB float tuples with values from 0-1.</p> Source code in <code>utils/colors.py</code> <pre><code>def load_default_palette() -&gt; List[Tuple[float, float, float]]:\n    \"\"\"Get Houdini's default 36 color palette.\n\n    Returns:\n        List of RGB float tuples representing default colors\n\n    Note:\n        The default palette includes white, black, grays, and various hues.\n        Colors are returned as RGB float tuples with values from 0-1.\n    \"\"\"\n    return [\n        (1, 1, 1), (0.839, 0.839, 0.839), (0.6, 0.6, 0.6),\n        (0.478, 0.478, 0.478), (0.306, 0.306, 0.306), (0, 0, 0),\n        (0.384, 0.184, 0.329), (0.576, 0.208, 0.475),\n        (0.89, 0.412, 0.761), (0.565, 0.494, 0.863),\n        (0.451, 0.369, 0.796), (0.322, 0.259, 0.58),\n        (0.38, 0.408, 0.553), (0.518, 0.561, 0.741),\n        (0.71, 0.784, 1), (0.584, 0.776, 1),\n        (0.29, 0.565, 0.886), (0.094, 0.369, 0.69),\n        (0.188, 0.529, 0.459), (0.145, 0.667, 0.557),\n        (0.616, 0.871, 0.769), (0.765, 1, 0.576),\n        (0.475, 0.812, 0.204), (0.302, 0.525, 0.114),\n        (1, 0.725, 0), (0.996, 0.933, 0),\n        (1, 0.976, 0.666), (0.976, 0.78, 0.263),\n        (0.71, 0.518, 0.004), (0.573, 0.353, 0),\n        (0.624, 0.329, 0.396), (1, 0.529, 0.624),\n        (0.996, 0.682, 0.682), (0.98, 0.275, 0.275),\n        (1, 0, 0), (0.8, 0.016, 0.016)\n    ]\n</code></pre>"},{"location":"reference/utils/colors/#utils.colors.validate_palette_file","title":"<code>validate_palette_file(file_path, importing=True)</code>","text":"<p>Validate if a file is a valid Houdini color palette file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to the palette file</p> required <code>importing</code> <code>bool</code> <p>Whether file is being imported (requires content)</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if file is valid, False if invalid</p> Notes <p>Valid palette files must: - Be named \"opColorPalette.def\" - Exist at the specified path - Contain content if importing=True</p> Example <p>validate_palette_file(\"path/to/opColorPalette.def\") True</p> Source code in <code>utils/colors.py</code> <pre><code>def validate_palette_file(file_path: Union[str, Path], importing: bool = True) -&gt; bool:\n    \"\"\"Validate if a file is a valid Houdini color palette file.\n\n    Args:\n        file_path: Path to the palette file\n        importing: Whether file is being imported (requires content)\n\n    Returns:\n        True if file is valid, False if invalid\n\n    Notes:\n        Valid palette files must:\n        - Be named \"opColorPalette.def\"\n        - Exist at the specified path\n        - Contain content if importing=True\n\n    Example:\n        &gt;&gt;&gt; validate_palette_file(\"path/to/opColorPalette.def\")\n        True\n    \"\"\"\n    file_path = Path(file_path)\n    if file_path.name != \"opColorPalette.def\":\n        hou.ui.displayMessage(\"The selected file is not called opColorPalette.def, therefore it is not a Houdini node color palette file.\")\n        return False\n\n    if not file_path.exists():\n        hou.ui.displayMessage(\"The selected file does not exist. Use the 'Reset to Houdini Standard' button to populate the main list with the default colors.\")\n        return False\n\n    if file_path.stat().st_size == 0 and not importing:\n        hou.ui.displayMessage(\"The selected file is empty, so cannot import.\")\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/utils/decorators/","title":"decorators.py","text":"<p>Utility decorators for NodeWeaver.</p> <p>This module provides decorators used throughout the NodeWeaver package to enhance functionality and development workflow. It includes decorators for module reloading, Houdini update mode management, and other utility purposes.</p> Features <ul> <li>Automatic module reloading for development</li> <li>Temporary update mode modification</li> <li>Performance optimization helpers</li> </ul>"},{"location":"reference/utils/decorators/#utils.decorators.pause_update_mode","title":"<code>pause_update_mode(func)</code>","text":"<p>Temporarily set Houdini's update mode to Manual during function execution.</p> <p>This decorator pauses Houdini's cooking and viewport updates during the decorated function's execution by setting the update mode to Manual. The original update mode is restored after execution, even if the function raises an exception.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to wrap</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Wrapped function that executes with paused updates</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @pause_update_mode\n... def heavy_node_operation():\n...     # Operations run with updates paused\n...     pass\n</code></pre> <pre><code>&gt;&gt;&gt; @pause_update_mode\n... def batch_process_nodes(nodes):\n...     for node in nodes:\n...         # Each iteration runs without triggering updates\n...         node.setColor((1, 0, 0))\n</code></pre> Notes <ul> <li>Use this decorator for operations that would normally trigger many node   cooks or viewport updates</li> <li>The original update mode is always restored, even if the function raises   an exception</li> <li>This can significantly improve performance for batch operations</li> <li>Updates are deferred until after the function completes</li> </ul> Warning <p>Be cautious when using this with functions that rely on node cooking or viewport feedback during their execution, as these will be delayed until the function completes.</p> <p>Since: 1.0.0</p> Source code in <code>utils/decorators.py</code> <pre><code>def pause_update_mode(func: Callable) -&gt; Callable:\n    \"\"\"Temporarily set Houdini's update mode to Manual during function execution.\n\n    This decorator pauses Houdini's cooking and viewport updates during the decorated\n    function's execution by setting the update mode to Manual. The original update mode\n    is restored after execution, even if the function raises an exception.\n\n    Args:\n        func: Function to wrap\n\n    Returns:\n        Wrapped function that executes with paused updates\n\n    Examples:\n        &gt;&gt;&gt; @pause_update_mode\n        ... def heavy_node_operation():\n        ...     # Operations run with updates paused\n        ...     pass\n\n        &gt;&gt;&gt; @pause_update_mode\n        ... def batch_process_nodes(nodes):\n        ...     for node in nodes:\n        ...         # Each iteration runs without triggering updates\n        ...         node.setColor((1, 0, 0))\n\n    Notes:\n        - Use this decorator for operations that would normally trigger many node\n          cooks or viewport updates\n        - The original update mode is always restored, even if the function raises\n          an exception\n        - This can significantly improve performance for batch operations\n        - Updates are deferred until after the function completes\n\n    Warning:\n        Be cautious when using this with functions that rely on node cooking or\n        viewport feedback during their execution, as these will be delayed until\n        the function completes.\n\n    Since: 1.0.0\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        original_mode = hou.updateModeSetting()\n        try:\n            hou.setUpdateMode(hou.updateMode.Manual)\n            return func(*args, **kwargs)\n        finally:\n            hou.setUpdateMode(original_mode)\n    return wrapper\n</code></pre>"},{"location":"reference/utils/decorators/#utils.decorators.reload_before_run","title":"<code>reload_before_run(func)</code>","text":"<p>Decorator that reloads the module containing the decorated function before execution.</p> <p>This decorator automatically reloads the module containing the decorated function before running it. This is useful during development when functions are called through Houdini callbacks or the Python shell.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to decorate</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Wrapped function that reloads its own module before executing</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @reload_before_run\n... def my_function():\n...     pass\n</code></pre> <pre><code>&gt;&gt;&gt; # In a callback:\n&gt;&gt;&gt; # from my_module import my_function; my_function()\n</code></pre> Notes <ul> <li>Only reloads the specific module containing the decorated function</li> <li>Does nothing if the module isn't found in sys.modules</li> <li>Preserves the original function's metadata using functools.wraps</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/decorators.py</code> <pre><code>def reload_before_run(func: Callable) -&gt; Callable:\n    \"\"\"Decorator that reloads the module containing the decorated function before execution.\n\n    This decorator automatically reloads the module containing the decorated function\n    before running it. This is useful during development when functions are called\n    through Houdini callbacks or the Python shell.\n\n    Args:\n        func: Function to decorate\n\n    Returns:\n        Wrapped function that reloads its own module before executing\n\n    Examples:\n        &gt;&gt;&gt; @reload_before_run\n        ... def my_function():\n        ...     pass\n\n        &gt;&gt;&gt; # In a callback:\n        &gt;&gt;&gt; # from my_module import my_function; my_function()\n\n    Notes:\n        - Only reloads the specific module containing the decorated function\n        - Does nothing if the module isn't found in sys.modules\n        - Preserves the original function's metadata using functools.wraps\n\n    Since: 1.0.0\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        module_name = func.__module__\n        if module_name in sys.modules:\n            reload(sys.modules[module_name])\n        return func(*args, **kwargs)\n    return wrapper\n</code></pre>"},{"location":"reference/utils/files/","title":"files.py","text":"<p>File operation utilities for NodeWeaver.</p> <p>This module provides utilities for reading and writing files, with a focus on JSON handling and validation. It includes functions for safe file operations with proper error handling and user feedback.</p>"},{"location":"reference/utils/files/#utils.files.read_json","title":"<code>read_json(path)</code>","text":"<p>Read and validate a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to JSON file as string or Path object</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary of JSON contents if valid, None if invalid</p> Notes <ul> <li>Validates file existence and .json extension</li> <li>Checks for non-empty content</li> <li>Prints warning messages for invalid files</li> </ul> Example <p>data = read_json(\"config/settings.json\") if data: ...     print(\"Settings loaded\")</p> <p>Since: 1.0.0</p> Source code in <code>utils/files.py</code> <pre><code>def read_json(path: Union[str, Path]) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Read and validate a JSON file.\n\n    Args:\n        path: Path to JSON file as string or Path object\n\n    Returns:\n        Dictionary of JSON contents if valid, None if invalid\n\n    Notes:\n        - Validates file existence and .json extension\n        - Checks for non-empty content\n        - Prints warning messages for invalid files\n\n    Example:\n        &gt;&gt;&gt; data = read_json(\"config/settings.json\")\n        &gt;&gt;&gt; if data:\n        ...     print(\"Settings loaded\")\n\n    Since: 1.0.0\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n\n    if not path.exists() or path.suffix != \".json\":\n        print(f\"JSON file either does not exist at {path} or doesn't end with .json. File not read.\")\n        return None\n\n    if path.stat().st_size == 0:\n        print(f\"JSON file at {path} is empty. File not read.\")\n        return None\n\n    try:\n        with open(path) as json_file:\n            return json.load(json_file)\n    except json.JSONDecodeError:\n        print(f\"Invalid JSON content in {path}\")\n        return None\n</code></pre>"},{"location":"reference/utils/files/#utils.files.write_json","title":"<code>write_json(path, data, indent=2, create_dirs=True, overwrite=False)</code>","text":"<p>Write a dictionary to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to JSON file as string or Path object</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary to write to file</p> required <code>indent</code> <code>int</code> <p>Number of spaces for JSON indentation</p> <code>2</code> <code>create_dirs</code> <code>bool</code> <p>Whether to create parent directories if they don't exist</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file without prompting</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if write successful, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"setting\": \"value\"}\n&gt;&gt;&gt; write_json(\"config/new.json\", data, create_dirs=True)\nTrue\n</code></pre> Notes <ul> <li>Creates parent directories if create_dirs=True</li> <li>Prompts for confirmation before overwriting unless overwrite=True</li> <li>Uses consistent indentation for readability</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/files.py</code> <pre><code>def write_json(path: Union[str, Path],\n                data: Dict[str, Any],\n                indent: int = 2,\n                create_dirs: bool = True,\n                overwrite: bool = False) -&gt; bool:\n    \"\"\"Write a dictionary to a JSON file.\n\n    Args:\n        path: Path to JSON file as string or Path object\n        data: Dictionary to write to file\n        indent: Number of spaces for JSON indentation\n        create_dirs: Whether to create parent directories if they don't exist\n        overwrite: Whether to overwrite existing file without prompting\n\n    Returns:\n        True if write successful, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; data = {\"setting\": \"value\"}\n        &gt;&gt;&gt; write_json(\"config/new.json\", data, create_dirs=True)\n        True\n\n    Notes:\n        - Creates parent directories if create_dirs=True\n        - Prompts for confirmation before overwriting unless overwrite=True\n        - Uses consistent indentation for readability\n\n    Since: 1.0.0\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n\n    if path.exists() and not overwrite:\n        response = hou.ui.displayMessage(\n            f\"The file at\\n{path}\\nalready exists, would you like to overwrite it?\",\n            buttons=(\"Yes\", \"No\")\n        )\n        if response == 1:\n            return False\n\n    try:\n        if create_dirs:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        with open(path, \"w\") as f:\n            json.dump(data, f, indent=indent)\n        return True\n\n    except OSError as e:\n        hou.ui.displayMessage(f\"Error writing JSON file: {str(e)}\")\n        return False\n</code></pre>"},{"location":"reference/utils/hda/","title":"hda.py","text":"<p>Utility functions for working with Houdini Digital Assets (HDAs).</p> <p>This module provides utilities for managing and updating HDAs, particularly focusing on section management and source file synchronization.</p> Note <p>All operations that modify HDAs automatically handle update mode management to ensure consistent state.</p>"},{"location":"reference/utils/hda/#utils.hda.update_hda_sections_from_source_files","title":"<code>update_hda_sections_from_source_files(hdas=None)</code>","text":"<p>Update HDA sections with contents from their source files.</p> <p>Updates each section's content by reading from source files specified in the HDA's extra options. Source file paths should be defined in the extra options with keys in the format \"{section_name}/Source\".</p> <p>Parameters:</p> Name Type Description Default <code>hdas</code> <code>Optional[Union[Node, List[Node]]]</code> <p>HDA node or list of HDA nodes to update. If None, uses selected nodes.</p> <code>None</code> Example Notes <ul> <li>The function maintains a summary of successful updates and errors</li> <li>Sections without specified source files are skipped</li> <li>Empty source files are skipped</li> <li>Updates are performed with update mode set to Manual</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/hda.py</code> <pre><code>@pause_update_mode\ndef update_hda_sections_from_source_files(hdas: Optional[Union[hou.Node, List[hou.Node]]] = None) -&gt; None:\n    \"\"\"Update HDA sections with contents from their source files.\n\n    Updates each section's content by reading from source files specified in the HDA's\n    extra options. Source file paths should be defined in the extra options with keys\n    in the format \"{section_name}/Source\".\n\n    Args:\n        hdas: HDA node or list of HDA nodes to update. If None, uses selected nodes.\n\n    Example:\n        # Update a specific HDA\n        &gt;&gt;&gt; node = hou.node('/obj/my_hda')\n        &gt;&gt;&gt; update_hda_sections_from_source_files(node)\n\n        # Update multiple HDAs\n        &gt;&gt;&gt; nodes = [hou.node('/obj/hda1'), hou.node('/obj/hda2')]\n        &gt;&gt;&gt; update_hda_sections_from_source_files(nodes)\n\n        # Update selected HDAs\n        &gt;&gt;&gt; update_hda_sections_from_source_files()\n\n    Notes:\n        - The function maintains a summary of successful updates and errors\n        - Sections without specified source files are skipped\n        - Empty source files are skipped\n        - Updates are performed with update mode set to Manual\n\n    Since: 1.0.0\n    \"\"\"\n    # Handle input types\n    if hdas is None:\n        hdas = hou.selectedNodes()\n    elif isinstance(hdas, hou.Node):\n        hdas = [hdas]\n\n    # Track overall success\n    success_count = 0\n    error_count = 0\n\n    for hda in hdas:\n        try:\n            definition = hda.type().definition()\n            if not definition:\n                print(f\"Warning: {hda.path()} is not an HDA\")\n                continue\n\n            sections = definition.sections()\n            extra_options = definition.extraFileOptions()\n            section_updates = 0\n\n            for section_name, section in sections.items():\n                source_key = f\"{section_name}/Source\"\n\n                # Skip if source not specified\n                if source_key not in extra_options:\n                    continue\n\n                # Skip if source path is empty\n                source_path = extra_options[source_key].strip()\n                if not source_path:\n                    continue\n\n                source_path = Path(source_path)\n                if not source_path.exists():\n                    print(f\"Warning: Source file not found for {definition.description()}: {source_path}\")\n                    continue\n\n                try:\n                    file_contents = source_path.read_text()\n                    if file_contents.strip():\n                        section.setContents(file_contents)\n                        section_updates += 1\n                        print(f\"{definition.description()}: Updated section {section_name} from {source_path}\")\n                except Exception as e:\n                    print(f\"{definition.description()}: Error reading {source_path}: {str(e)}\")\n                    error_count += 1\n\n            if section_updates &gt; 0:\n                print(f\"{definition.description()}: Updated {section_updates} sections\")\n                success_count += 1\n\n        except Exception as e:\n            print(f\"Error processing HDA {definition.description()}: {str(e)}\")\n            error_count += 1\n\n    # Print summary\n    if success_count or error_count:\n        print(f\"\\nUpdate Summary:\")\n        print(f\"Successfully processed: {success_count} HDAs\")\n        if error_count:\n            print(f\"Errors encountered: {error_count}\")\n    else:\n        print(\"No HDAs were processed\")\n</code></pre>"},{"location":"reference/utils/hda/#utils.hda.update_hda_sections_from_source_files--update-a-specific-hda","title":"Update a specific HDA","text":"<p>node = hou.node('/obj/my_hda') update_hda_sections_from_source_files(node)</p>"},{"location":"reference/utils/hda/#utils.hda.update_hda_sections_from_source_files--update-multiple-hdas","title":"Update multiple HDAs","text":"<p>nodes = [hou.node('/obj/hda1'), hou.node('/obj/hda2')] update_hda_sections_from_source_files(nodes)</p>"},{"location":"reference/utils/hda/#utils.hda.update_hda_sections_from_source_files--update-selected-hdas","title":"Update selected HDAs","text":"<p>update_hda_sections_from_source_files()</p>"},{"location":"reference/utils/houdini/","title":"houdini.py","text":"<p>Utility functions for Houdini environment and configuration.</p> <p>This module provides utilities for managing Houdini's environment variables and configuration settings. It focuses on persistent changes that survive between sessions.</p>"},{"location":"reference/utils/houdini/#utils.houdini.set_env_var","title":"<code>set_env_var(var_name, var_value)</code>","text":"<p>Set a Houdini environment variable and save to ensure persistence.</p> <p>Parameters:</p> Name Type Description Default <code>var_name</code> <code>str</code> <p>Environment variable name</p> required <code>var_value</code> <code>Union[str, int, float]</code> <p>Value to set, converted to string</p> required Notes <ul> <li>Uses both hscript and Python methods to ensure compatibility</li> <li>Saves the hip file to persist the environment change</li> <li>Previous value is overwritten without warning</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; set_env_var(\"MY_TOOL_PATH\", \"/custom/path\")\n&gt;&gt;&gt; set_env_var(\"CACHE_SIZE\", 1024)\n</code></pre> Warning <p>This function saves the hip file. Ensure all changes are committed before calling.</p> <p>Since: 1.0.0</p> Source code in <code>utils/houdini.py</code> <pre><code>def set_env_var(var_name: str, var_value: Union[str, int, float]) -&gt; None:\n    \"\"\"Set a Houdini environment variable and save to ensure persistence.\n\n    Args:\n        var_name: Environment variable name\n        var_value: Value to set, converted to string\n\n    Notes:\n        - Uses both hscript and Python methods to ensure compatibility\n        - Saves the hip file to persist the environment change\n        - Previous value is overwritten without warning\n\n    Examples:\n        &gt;&gt;&gt; set_env_var(\"MY_TOOL_PATH\", \"/custom/path\")\n        &gt;&gt;&gt; set_env_var(\"CACHE_SIZE\", 1024)\n\n    Warning:\n        This function saves the hip file. Ensure all changes are committed\n        before calling.\n\n    Since: 1.0.0\n    \"\"\"\n    str_value = str(var_value)\n    hou.hscript(f\"setenv {var_name}={str_value}\")\n    hou.putenv(var_name, str_value)\n    hou.hipFile.save(None, False)\n</code></pre>"},{"location":"reference/utils/mparms/","title":"mparms.py","text":"<p>Functions for advanced multi-parameter operations in Houdini.</p> <p>This module provides functionality for performing operations on multiparms that aren't possible with the default UI. It handles:</p> <ul> <li>Layer management and organization</li> <li>Parameter value manipulation</li> <li>Layer swapping and duplication</li> <li>Input/output management</li> <li>Layer isolation and stacking</li> </ul> Notes <p>Each instance of a multiparm is referred to as a layer in naming conventions. When setting up multiparms for swap buttons: 1. Create layindex# and layendnum# parameters 2. Set appropriate channels 3. Configure disable conditions</p>"},{"location":"reference/utils/mparms/#utils.mparms.duplicateLayer","title":"<code>duplicateLayer(kwargs)</code>","text":"<p>Duplicate the UI and nodes of a layer in the mparm. UPDATED FOR 20.0: When inserting, uses int(index)+1 instead of int(index).</p> Source code in <code>utils/mparms.py</code> <pre><code>def duplicateLayer(kwargs):\n    \"\"\"\n    Duplicate the UI and nodes of a layer in the mparm.\n    UPDATED FOR 20.0: When inserting, uses int(index)+1 instead of int(index).\n\n    \"\"\"\n    node = kwargs['node']\n    button = kwargs['parm']\n    index = kwargs['script_multiparm_index']\n\n    #Raise error if parameter hierarchy is configured incorrectly\n    if not button.tuple().isMultiParmInstance():\n        raise hou.NodeWarning('Button is not inside a multiparm block.')\n\n    mparm = button.tuple().parentMultiParm()\n    # Get the other parameters inside this multiparm layer so we can duplicate them.\n    mparm_template = mparm.parmTemplate().parmTemplates()\n    # Create a new mparm instance just after this instance.\n    mparm.insertMultiParmInstance(int(index)+1)\n\n    #print(f'to duplicate = {int(index)-1}   |   duplicated = {index}')\n    # Duplicate parm data\n    prepForSwap(kwargs, mparm_template, index, 1, duplicate=True)\n</code></pre>"},{"location":"reference/utils/mparms/#utils.mparms.prepForSwap","title":"<code>prepForSwap(kwargs, mparm_template, index, swap_dir, duplicate=False)</code>","text":"<p>Find the parms between 1 layer and the one being swapped with in order to switch values. mparm_template is the tuple of all the parms in the multiparm block. (hou.parmTemplate)</p> Source code in <code>utils/mparms.py</code> <pre><code>def prepForSwap(kwargs, mparm_template:tuple, index:int, swap_dir:int, duplicate:bool=False):\n    \"\"\"\n    Find the parms between 1 layer and the one being swapped with in order to switch values.\n    mparm_template is the tuple of all the parms in the multiparm block. (hou.parmTemplate)\n\n    \"\"\"\n    node = kwargs['node']\n    debug = 0\n\n    for i, parm_template in enumerate(mparm_template):\n        # If the current parameter is of a valid type, check if it has channels\n        if parm_template.type() in [\n                hou.parmTemplateType.Int,\n                hou.parmTemplateType.Float,\n                hou.parmTemplateType.String,\n                hou.parmTemplateType.Toggle,\n                hou.parmTemplateType.Menu]:\n\n            # Note that vector channels are suffixed after multiparm index - 'vector_#x' instead of 'vector_x#'\n            parm_name = parm_template.name()\n            parm_swap_name = parm_template.name()\n            nesting_depth = int(kwargs[\"script_multiparm_nesting\"])\n\n            # Replace # with multiparm numbers, leaving the last # to be replaced depending on the swap direction\n            if debug == 1:\n                print(f'###########################################\\nINITIAL:\\nname1 = {parm_name}   |   name2 = {parm_swap_name}   |   parmTemplate = {parm_template}')\n            for i in range(nesting_depth-1):\n                # Create the name of the kwargs entry that correctly relates to the multiparm index.\n                # The outermost index has the biggest number, while the innermost one doesn't have a number.\n                index_find = nesting_depth-i\n                mparm_index_name = f'script_multiparm_index{index_find}'\n                if index_find == 1:\n                    mparm_index_name = 'script_multiparm_index'\n                index_for_replacing = kwargs[mparm_index_name]\n                parm_name = parm_name.replace('#',f'{index_for_replacing}', 1) # Replace the first # with number from the main mparm\n                parm_swap_name = parm_swap_name.replace('#',f'{index_for_replacing}', 1) # Replace the first # with number from the main mparm\n\n            parm_name = parm_name.replace('#',f'{index}')\n            parm_swap_name = parm_swap_name.replace('#',f'{int(index)+int(swap_dir)}')\n            if debug == 1:\n                print(f'AFTER RENAMING:\\nname1 = {parm_name}   |   name2 = {parm_swap_name}')\n\n            # If the parm is a vector, check if it has components then swap each one.\n            if parm_template.numComponents() &gt; 1:\n                vec_comp = 'x'\n                for c in range(parm_template.numComponents()):\n                    if parm_template.namingScheme() == hou.parmNamingScheme.XYZW:\n                        vec_comp = ['x','y','z','w'][c]\n                    elif parm_template.namingScheme() == hou.parmNamingScheme.RGBA:\n                        vec_comp = ['r','g','b','a'][c]\n                    elif parm_template.namingScheme() == hou.parmNamingScheme.UVW:\n                        vec_comp = ['u','v','w'][c]\n                    elif parm_template.namingScheme() == hou.parmNamingScheme.Base1:\n                        vec_comp = ['1','2','3','4'][c]\n                    parm_name_vec = parm_name+vec_comp\n                    parm_swap_name_vec = parm_swap_name+vec_comp\n                    #print(f'name1 = {parm_name}   |   name2 = {parm_swap_name}')\n                    swapValues(kwargs, parm_name_vec, parm_swap_name_vec, duplicate, debug)\n\n            # If the parm is not a vector, simply swap the values.\n            elif parm_template.numComponents() == 1: # If the parm has 1 value\n                #print(f'name1 = {parm_name}   |   name2 = {parm_swap_name}')\n                swapValues(kwargs, parm_name, parm_swap_name, duplicate, debug)\n\n        #if a folder is found, determine if it's a nested multiparm\n        elif parm_template.type() == hou.parmTemplateType.Folder:\n            # If it is, compare the number of instances in each multiparm\n            if parm_template.folderType() == hou.folderType.MultiparmBlock:\n                get_nested_mparm = parm_template.name().replace('#',f'{index}')\n                get_swap_nested_mparm = parm_template.name().replace('#',f'{index+swap_dir}')\n                nested_mparm_count = node.evalParm(get_nested_mparm)\n                swap_nested_mparm_count = node.evalParm(get_swap_nested_mparm)\n\n                # If both multiparms have the same number of instances, swap nested parameter values\n                if nested_mparm_count == swap_nested_mparm_count:\n                    for j in range(nested_mparm_count):\n                        parm_a = node.parm(get_nested_mparm).parmTemplate().parmTemplates()[j-1].name().replace('#',f'{index}')\n                        parm_b = node.parm(get_swap_nested_mparm).parmTemplate().parmTemplates()[j-1].name().replace('#',f'{index+swap_dir}')\n                        swapValues(kwargs, parm_a, parm_b, duplicate, debug)\n                # Otherwise, save values to a temporary holder\n                else:\n                    temp_a = list()\n                    temp_b = list()\n                    for j in range(nested_mparm_count):\n                        nested_parm = node.parm(get_nested_mparm).parmTemplate().parmTemplates()[j-1].name().replace('#',f'{index}')\n                        if len(node.parm(nested_parm).keyframes()) &gt; 0:\n                            temp_a.append(node.parm(nested_parm).keyframes())\n                        else:\n                            temp_a.append(node.parm(nested_parm).rawValue())\n\n                    for j in range(swap_nested_mparm_count):\n                        nested_parm = node.parm(get_swap_nested_mparm).parmTemplate().parmTemplates()[j-1].name().replace('#',f'{index+swap_dir}')\n                        if len(node.parm(nested_parm).keyframes()) &gt; 0:\n                            temp_b.append(node.parm(nested_parm).keyframes())\n                        else:\n                            temp_b.append(node.parm(nested_parm).rawValue())\n\n                    # Initialize number of multiparm blocks\n                    swapValues(kwargs, get_nested_mparm, get_swap_nested_mparm, duplicate, debug)\n\n                    # And update each block from the temporary holders\n                    for k in range(swap_nested_mparm_count):\n                        parm_a = node.parm(get_nested_mparm).parmTemplate().parmTemplates()[k-1].name().replace('#',f'{index}')\n                        node.parm(parm_a).deleteAllKeyframes()\n                        try:\n                            node.parm(parm_a).set(temp_b[k])\n                        except:\n                            node.parm(parm_a).setKeyframes(temp_b[k])\n                    for k in range(nested_mparm_count):\n                        parm_b = node.parm(get_swap_nested_mparm).parmTemplate().parmTemplates()[k-1].name().replace('#',f'{index+swap_dir}')\n                        node.parm(parm_b).deleteAllKeyframes()\n                        try:\n                            node.parm(parm_b).set(temp_a[k])\n                        except:\n                            node.parm(parm_b).setKeyframes(temp_a[k])\n\n            #if it's not a multiparm, dive inside and swap each nested parameter\n            else:\n                prepForSwap(kwargs, parm_template.parmTemplates(), index, swap_dir, duplicate)\n</code></pre>"},{"location":"reference/utils/mparms/#utils.mparms.resetLayer","title":"<code>resetLayer(kwargs)</code>","text":"<p>Resets all the parms per layer. Checks the parm it is called on to find its parent and then resets.</p> Source code in <code>utils/mparms.py</code> <pre><code>def resetLayer(kwargs):\n    \"\"\"\n    Resets all the parms per layer. Checks the parm it is called on to find its\n    parent and then resets.\n\n    \"\"\"\n    layerNum = kwargs['script_multiparm_index']\n    allParms = kwargs['parm'].parentMultiParm().multiParmInstances()\n    if hou.ui.displayMessage(\"Would you like to reset the parameters for this layer?\", buttons=(\"Yes\", \"No\")) == 1:\n        return\n    for parm in allParms:\n        if int(parm.multiParmInstanceIndices()[-1]) == int(layerNum):\n            if parm.parmTemplate().type() == hou.parmTemplateType.Ramp:\n                parm.revertToRampDefaults()\n            else:\n                parm.revertToDefaults()\n</code></pre>"},{"location":"reference/utils/mparms/#utils.mparms.swapLayers","title":"<code>swapLayers(kwargs, swap_with_next)</code>","text":"<p>Swap the parameters of the layer with one in either direction.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>Node callback dictionary</p> required <code>swap_with_next</code> <code>bool</code> <p>Whether to swap with next layer (True) or previous (False)</p> required Notes <ul> <li>Handles all parameter types</li> <li>Preserves parameter relationships</li> <li>Maintains keyframes and expressions</li> <li>Updates UI appropriately</li> </ul> <p>Raises:</p> Type Description <code>NodeWarning</code> <p>If swap is not possible</p> Example <p>swapLayers(kwargs, True)  # Swap with next layer</p> Source code in <code>utils/mparms.py</code> <pre><code>def swapLayers(kwargs: Dict[str, Any], swap_with_next: bool) -&gt; None:\n    \"\"\"Swap the parameters of the layer with one in either direction.\n\n    Args:\n        kwargs: Node callback dictionary\n        swap_with_next: Whether to swap with next layer (True) or previous (False)\n\n    Notes:\n        - Handles all parameter types\n        - Preserves parameter relationships\n        - Maintains keyframes and expressions\n        - Updates UI appropriately\n\n    Raises:\n        hou.NodeWarning: If swap is not possible\n\n    Example:\n        &gt;&gt;&gt; swapLayers(kwargs, True)  # Swap with next layer\n    \"\"\"\n    node = kwargs['node']\n    button = kwargs['parm']\n    index = int(kwargs['script_multiparm_index'])\n    target_swap_dir = int(swap_with_next)*2-1\n\n    #Raise error if parameter hierarchy is configured incorrectly\n    if not button.tuple().isMultiParmInstance():\n        raise hou.NodeWarning('Button is not inside a multiparm block.')\n\n    mparm = button.tuple().parentMultiParm()\n    #Count the number of multiparm instances -&gt; raise errors if swapping is not allowed\n    mparm_count = node.parm(mparm.name()).evalAsInt()\n    # Get the other parameters inside this multiparm block so we can start swapping.\n    mparm_template = mparm.parmTemplate().parmTemplates()\n\n    #Raise errors if trying to swap up on first block, or swap down on last block\n    if swap_with_next is True and index == mparm_count:\n            raise hou.NodeWarning('No value below to swap with.')\n    elif swap_with_next is False and index == 1:\n            raise hou.NodeWarning('No value above to swap with.')\n\n    prepForSwap(kwargs, mparm_template, index, target_swap_dir)\n</code></pre>"},{"location":"reference/utils/mparms/#utils.mparms.swapValues","title":"<code>swapValues(kwargs, parm_a_name, parm_b_name, duplicate=False, debug=0)</code>","text":"<p>When supplied with two parameter names, this function will swap their values.</p> Source code in <code>utils/mparms.py</code> <pre><code>def swapValues(kwargs, parm_a_name:str, parm_b_name:str, duplicate:bool=False, debug:int=0):\n    \"\"\"\n    When supplied with two parameter names, this function will swap their values.\n\n    \"\"\"\n    node = kwargs['node']\n    parm_a = node.parm(parm_a_name)\n    parm_b = node.parm(parm_b_name)\n\n    #print(f'a = {a}   |   parm_a = {parm_a}   |   b = {b}   |   parm_b = {parm_b}')\n    if len(parm_a.keyframes()) == 0:\n        #if both params have no keyframes\n        if len(parm_b.keyframes()) == 0:\n            parm_a_value = parm_a.rawValue()\n            parm_b_value = parm_b.rawValue()\n            if parm_a_value == 'on':\n                parm_a_value = 1\n            elif parm_a_value == 'off':\n                parm_a_value = 0\n            if parm_b_value == 'on':\n                parm_b_value = 1\n            elif parm_b_value == 'off':\n                parm_b_value = 0\n            if duplicate == False:\n                parm_a.set(parm_b_value)\n                parm_b.set(parm_a_value)\n            else:\n                if debug == 1:\n                    print(f'a = {parm_a}   |   parm_a_value = {parm_a_value}   |   b = {parm_b}   |   parm_b_value = {parm_b_value}')\n                parm_a.set(parm_a_value)\n                parm_b.set(parm_a_value)\n\n        #if A has no keyframes but B does, b cant have keyframes if duplicated\n        else:\n            parm_a_value = parm_a.rawValue()\n            parm_b_value = parm_b.keyframes()\n            if parm_a_value == 'on':\n                parm_a_value = 1\n            elif parm_a_value == 'off':\n                parm_a_value = 0\n            if duplicate == False:\n                parm_a.setKeyframes(parm_b_value)\n                parm_b.deleteAllKeyframes()\n                parm_b.set(parm_a_value)\n            else:\n                if debug == 1:\n                    print(f'a = {parm_a}   |   parm_a_value = {parm_a_value}   |   b = {parm_b}   |   parm_b_value = {parm_b_value}')\n                parm_a.set(parm_a_value)\n                parm_b.set(parm_a_value)\n\n    else:\n        #if A has keyframes but B doesn't\n        if len(parm_b.keyframes()) == 0:\n            parm_a_value = parm_a.keyframes()\n            parm_b_value = parm_b.rawValue()\n            if parm_b_value == 'on':\n                parm_b_value = 1\n            elif parm_b_value == 'off':\n                parm_b_value = 0\n            if duplicate == False:\n                parm_a.deleteAllKeyframes()\n                parm_a.set(parm_b_value)\n                parm_b.setKeyframes(parm_a_value)\n            else:\n                if debug == 1:\n                    print(f'a = {parm_a}   |   parm_a_value = {parm_a_value}   |   b = {parm_b}   |   parm_b_value = {parm_b_value}')\n                parm_a.setKeyframes(parm_a_value)\n                parm_b.setKeyframes(parm_a_value)\n\n        #if both params have keyframes\n        else:\n            parm_a_value = parm_a.keyframes()\n            parm_b_value = parm_b.keyframes()\n            if duplicate == False:\n                parm_a.deleteAllKeyframes()\n                parm_a.setKeyframes(parm_b_value)\n                parm_b.deleteAllKeyframes()\n                parm_b.setKeyframes(parm_a_value)\n            else:\n                if debug == 1:\n                    print(f'a = {parm_a}   |   parm_a_value = {parm_a_value}   |   b = {parm_b}   |   parm_b_value = {parm_b_value}')\n                parm_a.setKeyframes(parm_a_value)\n                parm_b.deleteAllKeyframes()\n                parm_b.setKeyframes(parm_a_value)\n</code></pre>"},{"location":"reference/utils/nodes/","title":"nodes.py","text":"<p>Node manipulation utilities for Houdini.</p> <p>This module provides functions for creating, modifying, and managing Houdini nodes. It includes utilities for customization, replacement, and network building from templates.</p> <p>Classes:</p> Name Description <code>NetworkBuilder</code> <p>Builds node networks from JSON configurations</p> <p>Functions:</p> Name Description <code>customize_node</code> <p>Apply common customizations to nodes</p> <code>replace_with_null</code> <p>Replace nodes with null nodes</p>"},{"location":"reference/utils/nodes/#utils.nodes.NetworkBuilder","title":"<code>NetworkBuilder</code>","text":"<p>Builds Houdini node networks from JSON configurations.</p> <p>This class handles the creation of node networks based on JSON template definitions, including proper node creation, parameter setting, and connection management.</p> <p>Attributes:</p> Name Type Description <code>parent</code> <p>Parent node for network creation</p> <code>_created_nodes</code> <code>Dict[str, Node]</code> <p>Dictionary mapping node names to created nodes</p> Example <p>builder = NetworkBuilder(hou.node('/obj')) last_node = builder.build_from_template(\"my_template\")</p> <p>Since: 1.0.0</p> Source code in <code>utils/nodes.py</code> <pre><code>class NetworkBuilder:\n    \"\"\"Builds Houdini node networks from JSON configurations.\n\n    This class handles the creation of node networks based on JSON template\n    definitions, including proper node creation, parameter setting, and\n    connection management.\n\n    Attributes:\n        parent: Parent node for network creation\n        _created_nodes: Dictionary mapping node names to created nodes\n\n    Example:\n        &gt;&gt;&gt; builder = NetworkBuilder(hou.node('/obj'))\n        &gt;&gt;&gt; last_node = builder.build_from_template(\"my_template\")\n\n    Since: 1.0.0\n    \"\"\"\n\n    def __init__(self, parent_node: hou.Node):\n        \"\"\"Initialize with parent node for network creation.\n\n        Args:\n            parent_node: Node that will contain the network\n        \"\"\"\n        self.parent = parent_node\n        self._created_nodes: Dict[str, hou.Node] = {}\n\n    def build_from_template(self, template_name: str) -&gt; Optional[hou.Node]:\n        \"\"\"Build a network from a named template in the config file.\n\n        Args:\n            template_name: Name of template in example_networks.json\n\n        Returns:\n            The last created node or None if build fails\n\n        Raises:\n            ValueError: If template name is not found\n\n        Notes:\n            - Creates sticky note if template includes description\n            - Maintains node connections defined in template\n            - Preserves node positions and relationships\n\n        Since: 1.0.0\n        \"\"\"\n        config_path = Path(__file__).parent.parent / \"config/node_shape/example_networks.json\"\n        try:\n            with open(config_path) as f:\n                templates = json.load(f)\n        except (OSError, json.JSONDecodeError) as e:\n            hou.ui.displayMessage(f\"Error loading template: {str(e)}\")\n            return None\n\n        if template_name not in templates:\n            hou.ui.displayMessage(f\"Template '{template_name}' not found\")\n            return None\n\n        template = templates[template_name]\n\n        # Create sticky note if description provided\n        if \"sticky\" in template:\n            sticky = self.parent.createStickyNote()\n            sticky.setText(template[\"sticky\"])\n            sticky.setBounds(hou.BoundingRect(-2.7, -3.5, 3.7, -1))\n\n        # Create nodes from tree\n        last_node = None\n        for node_data in template[\"tree\"]:\n            last_node = self._create_node(node_data)\n\n        return last_node\n\n    def _create_node(self, node_data: Dict[str, Any]) -&gt; Optional[hou.Node]:\n        \"\"\"Create or configure a node based on template data.\n\n        Args:\n            node_data: Dictionary containing node configuration data\n\n        Returns:\n            Created/configured node\n        \"\"\"\n        # Determine target node - either create new or use HDA\n        if \"name\" in node_data:\n            parent = (self._created_nodes[node_data[\"subnet\"]]\n                    if \"subnet\" in node_data else self.parent)\n            node = parent.createNode(node_data[\"type_name\"], node_data[\"name\"])\n            self._created_nodes[node_data[\"name\"]] = node\n\n            if \"pos\" in node_data:\n                node.setPosition(hou.Vector2(node_data[\"pos\"]))\n\n            if \"flags\" in node_data:\n                node.setRenderFlag(\"render\" in node_data[\"flags\"])\n                node.setDisplayFlag(\"display\" in node_data[\"flags\"] and \"nodisplay\" not in node_data[\"flags\"])\n        else:\n            node = self.parent\n\n        # Configure parameters\n        for parm_type in [\"parms\", \"parmtuples\", \"expressions\"]:\n            if parm_type in node_data:\n                for name, value in node_data[parm_type].items():\n                    if parm_type == \"parms\":\n                        node.parm(name).set(value)\n                    elif parm_type == \"parmtuples\":\n                        node.parmTuple(name).set(value)\n                    elif parm_type == \"expressions\":\n                        node.parm(name).setExpression(value)\n\n        # Set inputs\n        if \"inputs\" in node_data:\n            for i, input_name in enumerate(node_data[\"inputs\"]):\n                input_node = self._created_nodes.get(input_name)\n                if input_node:\n                    node.setInput(i, input_node)\n\n        return node\n</code></pre>"},{"location":"reference/utils/nodes/#utils.nodes.NetworkBuilder.__init__","title":"<code>__init__(parent_node)</code>","text":"<p>Initialize with parent node for network creation.</p> <p>Parameters:</p> Name Type Description Default <code>parent_node</code> <code>Node</code> <p>Node that will contain the network</p> required Source code in <code>utils/nodes.py</code> <pre><code>def __init__(self, parent_node: hou.Node):\n    \"\"\"Initialize with parent node for network creation.\n\n    Args:\n        parent_node: Node that will contain the network\n    \"\"\"\n    self.parent = parent_node\n    self._created_nodes: Dict[str, hou.Node] = {}\n</code></pre>"},{"location":"reference/utils/nodes/#utils.nodes.NetworkBuilder.build_from_template","title":"<code>build_from_template(template_name)</code>","text":"<p>Build a network from a named template in the config file.</p> <p>Parameters:</p> Name Type Description Default <code>template_name</code> <code>str</code> <p>Name of template in example_networks.json</p> required <p>Returns:</p> Type Description <code>Optional[Node]</code> <p>The last created node or None if build fails</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If template name is not found</p> Notes <ul> <li>Creates sticky note if template includes description</li> <li>Maintains node connections defined in template</li> <li>Preserves node positions and relationships</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/nodes.py</code> <pre><code>def build_from_template(self, template_name: str) -&gt; Optional[hou.Node]:\n    \"\"\"Build a network from a named template in the config file.\n\n    Args:\n        template_name: Name of template in example_networks.json\n\n    Returns:\n        The last created node or None if build fails\n\n    Raises:\n        ValueError: If template name is not found\n\n    Notes:\n        - Creates sticky note if template includes description\n        - Maintains node connections defined in template\n        - Preserves node positions and relationships\n\n    Since: 1.0.0\n    \"\"\"\n    config_path = Path(__file__).parent.parent / \"config/node_shape/example_networks.json\"\n    try:\n        with open(config_path) as f:\n            templates = json.load(f)\n    except (OSError, json.JSONDecodeError) as e:\n        hou.ui.displayMessage(f\"Error loading template: {str(e)}\")\n        return None\n\n    if template_name not in templates:\n        hou.ui.displayMessage(f\"Template '{template_name}' not found\")\n        return None\n\n    template = templates[template_name]\n\n    # Create sticky note if description provided\n    if \"sticky\" in template:\n        sticky = self.parent.createStickyNote()\n        sticky.setText(template[\"sticky\"])\n        sticky.setBounds(hou.BoundingRect(-2.7, -3.5, 3.7, -1))\n\n    # Create nodes from tree\n    last_node = None\n    for node_data in template[\"tree\"]:\n        last_node = self._create_node(node_data)\n\n    return last_node\n</code></pre>"},{"location":"reference/utils/nodes/#utils.nodes.customize_node","title":"<code>customize_node(node, pos=None, color=None, shape=None, comment=None)</code>","text":"<p>Apply common customizations to a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to customize</p> required <code>pos</code> <code>Optional[Vector2]</code> <p>New position vector</p> <code>None</code> <code>color</code> <code>Optional[Color]</code> <p>New color</p> <code>None</code> <code>shape</code> <code>Optional[str]</code> <p>New node shape name</p> <code>None</code> <code>comment</code> <code>Optional[str]</code> <p>New comment text</p> <code>None</code> Example <p>node = hou.node('/obj/geo1') customize_node( ...     node, ...     pos=hou.Vector2(0, 0), ...     color=hou.Color((1, 0, 0)), ...     shape=\"rect\", ...     comment=\"Modified node\" ... )</p> Notes <ul> <li>Only applies customizations for non-None arguments</li> <li>Comments are automatically displayed when set</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/nodes.py</code> <pre><code>def customize_node(node: hou.Node,\n                  pos: Optional[hou.Vector2] = None,\n                  color: Optional[hou.Color] = None,\n                  shape: Optional[str] = None,\n                  comment: Optional[str] = None) -&gt; None:\n    \"\"\"Apply common customizations to a node.\n\n    Args:\n        node: Node to customize\n        pos: New position vector\n        color: New color\n        shape: New node shape name\n        comment: New comment text\n\n    Example:\n        &gt;&gt;&gt; node = hou.node('/obj/geo1')\n        &gt;&gt;&gt; customize_node(\n        ...     node,\n        ...     pos=hou.Vector2(0, 0),\n        ...     color=hou.Color((1, 0, 0)),\n        ...     shape=\"rect\",\n        ...     comment=\"Modified node\"\n        ... )\n\n    Notes:\n        - Only applies customizations for non-None arguments\n        - Comments are automatically displayed when set\n\n    Since: 1.0.0\n    \"\"\"\n    if pos:\n        node.setPosition(pos)\n    if color:\n        node.setColor(color)\n    if shape:\n        node.setUserData('nodeshape', shape)\n    if comment:\n        node.setComment(comment)\n        node.setGenericFlag(hou.nodeFlag.DisplayComment,True)\n</code></pre>"},{"location":"reference/utils/nodes/#utils.nodes.replace_with_null","title":"<code>replace_with_null(node, null_name)</code>","text":"<p>Create a null output node and return that if the current node isn't a null.</p> <p>Creates a null node connected to the input node's output and positioned below it. If the input node is already a null, returns it unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node to potentially replace</p> required <code>null_name</code> <code>str</code> <p>Name for the null node</p> required <p>Returns:</p> Type Description <code>Node</code> <p>Either the original node if it's already a null, or the new null node</p> Example <p>geo = hou.node('/obj/geo1') null = replace_with_null(geo, 'OUT_geo')</p> Notes <ul> <li>Positions null node 0.5 units left and 1 unit below input node</li> <li>Does not delete or modify the original node</li> <li>Returns existing null if one with the same name exists</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/nodes.py</code> <pre><code>def replace_with_null(node: hou.Node, null_name: str) -&gt; hou.Node:\n    \"\"\"Create a null output node and return that if the current node isn't a null.\n\n    Creates a null node connected to the input node's output and positioned\n    below it. If the input node is already a null, returns it unchanged.\n\n    Args:\n        node: Node to potentially replace\n        null_name: Name for the null node\n\n    Returns:\n        Either the original node if it's already a null, or the new null node\n\n    Example:\n        &gt;&gt;&gt; geo = hou.node('/obj/geo1')\n        &gt;&gt;&gt; null = replace_with_null(geo, 'OUT_geo')\n\n    Notes:\n        - Positions null node 0.5 units left and 1 unit below input node\n        - Does not delete or modify the original node\n        - Returns existing null if one with the same name exists\n\n    Since: 1.0.0\n    \"\"\"\n    if node.type().name() == \"null\":\n        return node\n\n    parent = node.parent()\n    find_node = parent.node(null_name)\n\n    if find_node is None:\n        find_node = node.createOutputNode(\"null\", null_name)\n        find_node.setPosition(node.position() + hou.Vector2((-0.5, -1)))\n\n    return find_node\n</code></pre>"},{"location":"reference/utils/parameters/","title":"parameters.py","text":"<p>Parameter manipulation utilities for Houdini.</p> <p>This module provides comprehensive utilities for working with Houdini parameters, including type checking, template modification, conditional logic handling, and parameter referencing. It focuses on maintaining parameter relationships while enabling complex modifications.</p> <p>Functions:</p> Name Description <code>is_parm_of_type</code> <p>Check parameter type</p> <code>all_parm_templates</code> <p>Iterate through all parameter templates</p> <code>modify_parm_templates</code> <p>Modify parameter templates with consistent naming</p> <code>modify_conditionals</code> <p>Update parameter conditional expressions</p> <code>relative_reference_multiparm</code> <p>Create relative parameter references</p> <code>reset_script_parms_to_default</code> <p>Reset script parameters to defaults</p> <code>mass_connect_parameters</code> <p>Bulk connect parameters between nodes</p>"},{"location":"reference/utils/parameters/#utils.parameters.all_parm_templates","title":"<code>all_parm_templates(group_or_folder)</code>","text":"<p>Get all parameter templates from a group or folder.</p> <p>Recursively retrieves all parameter templates, including those nested in folders, which aren't accessible through Houdini's default methods.</p> <p>Parameters:</p> Name Type Description Default <code>group_or_folder</code> <code>Union[ParmTemplateGroup, FolderParmTemplate]</code> <p>Parameter group or folder to search.</p> required <p>Returns:</p> Type Description <code>Generator[ParmTemplate]</code> <p>Generator[hou.ParmTemplate]: Generator yielding all parameter templates</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input is not a ParmTemplateGroup or FolderParmTemplate</p> Example <p>templates = list(all_parm_templates(node.parmTemplateGroup()))</p> Source code in <code>utils/parameters.py</code> <pre><code>def all_parm_templates(group_or_folder: Union[hou.ParmTemplateGroup, hou.FolderParmTemplate]) -&gt; Generator[hou.ParmTemplate]:\n    \"\"\"Get all parameter templates from a group or folder.\n\n    Recursively retrieves all parameter templates, including those nested in folders,\n    which aren't accessible through Houdini's default methods.\n\n    Args:\n        group_or_folder (Union[hou.ParmTemplateGroup, hou.FolderParmTemplate]):\n            Parameter group or folder to search.\n\n    Returns:\n        Generator[hou.ParmTemplate]: Generator yielding all parameter templates\n\n    Raises:\n        TypeError: If input is not a ParmTemplateGroup or FolderParmTemplate\n\n    Example:\n        &gt;&gt;&gt; templates = list(all_parm_templates(node.parmTemplateGroup()))\n    \"\"\"\n    for parm_template in group_or_folder.parmTemplates():\n        yield parm_template\n\n        # Note that we don't want to return parm templates inside multiparm\n        # blocks, so we verify that the folder parm template is actually\n        # for a folder.\n        if parm_template.type() == hou.parmTemplateType.Folder and parm_template.isActualFolder():\n            for sub_parm_template in all_parm_templates(parm_template):\n                yield sub_parm_template\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.is_parm_of_type","title":"<code>is_parm_of_type(parm, types=(hou.parmTemplateType.Int, hou.parmTemplateType.Float, hou.parmTemplateType.String))</code>","text":"<p>Check if parameter is of specified types.</p> <p>Parameters:</p> Name Type Description Default <code>parm</code> <code>Parm</code> <p>Parameter to check</p> required <code>types</code> <code>tuple[parmTemplateType]</code> <p>Tuple of parameter types to check against. Defaults to (Int, Float, String).</p> <code>(Int, Float, String)</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if parameter matches any of the specified types</p> Example <p>parm = node.parm('tx') is_parm_of_type(parm, (hou.parmTemplateType.Float,)) True</p> Source code in <code>utils/parameters.py</code> <pre><code>def is_parm_of_type(parm:hou.Parm,\n                types:tuple[hou.parmTemplateType]=(hou.parmTemplateType.Int,\n                                                    hou.parmTemplateType.Float,\n                                                    hou.parmTemplateType.String)) -&gt; bool:\n    \"\"\"Check if parameter is of specified types.\n\n    Args:\n        parm (hou.Parm): Parameter to check\n        types (tuple[hou.parmTemplateType], optional): Tuple of parameter types to check against.\n            Defaults to (Int, Float, String).\n\n    Returns:\n        bool: True if parameter matches any of the specified types\n\n    Example:\n        &gt;&gt;&gt; parm = node.parm('tx')\n        &gt;&gt;&gt; is_parm_of_type(parm, (hou.parmTemplateType.Float,))\n        True\n    \"\"\"\n    template = parm.parmTemplate()\n    if template.type() in types:\n        return True\n    return False\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.mass_connect_parameters","title":"<code>mass_connect_parameters(node)</code>","text":"<p>NOT FUNCTIONAL YET Prompts the user to select 2 nodes to copy parms between. In a final version of this, it will create a UI to prompt the user with where they can add modifications to the parm names in order to make them match if they don't have the same names.</p> Source code in <code>utils/parameters.py</code> <pre><code>def mass_connect_parameters(node:hou.Node):\n    \"\"\"\n    NOT FUNCTIONAL YET\n    Prompts the user to select 2 nodes to copy parms between. In a final version of\n    this, it will create a UI to prompt the user with where they can add modifications\n    to the parm names in order to make them match if they don't have the same names.\n\n    \"\"\"\n    def _set_modifiers(mods:dict):\n        \"\"\"\n        Recursive function that keeps asking the user if they want to modify the mods\n        until they are satified.\n\n        \"\"\"\n        a = [\"prefix\", \"suffix\", \"replace_from\", \"replace_to\"]\n        ui = hou.ui.displayMessage(f\"It is common to modify a parm name for a node when it is controlled by\\na master. You can set the changes you may have done here.\\nNote: these changes will only be searched for in master node parm names.\\nPrefix: {mods[a[0]]}\\nSuffix: {mods[a[1]]}\\n Replace (From): {mods[a[2]]}\\nReplace (To): {mods[a[3]]}\", buttons=(\"Adjust Prefix\", \"Adjust Suffix\", \"Adjust Replace From\", \"Adjust Replace To\", \"Continue\"))\n        if ui == 4:\n            return mods\n        else:\n            mods[a[ui]] = hou.ui.readInput(f\"Set value for {a[ui].replace('_', ' ').title()}\", initial_contents=mods[a[ui]])[1]\n            _set_modifiers(mods)\n\n\n    # First, make sure that the node being run from can be put at the end later, so remove here.\n    sel = list(hou.selectedNodes())\n    if node in sel:\n        sel.pop(sel.index(node))\n    # If not enough nodes are selected, prompt to select more\n    if len(sel) == 0:\n        hou.ui.displayMessage(\"The selected node will serve as the 'master' but you now need to select\\nnodes whose parms will be connected to it.\\n\", title=\"Only selected one node\", help=\"Tip: If you select 2 or more nodes when running the script, it will use\\nthe last selected one as the 'master'.\", severity=hou.severityType.Warning)\n        prompt = hou.ui.selectNode(initial_node=node, title=\"Select the nodes to connect to the master\", multiple_select=True)\n        if prompt is not None:\n            for path in prompt:\n                if hou.node(path) != node:\n                    sel.append(hou.node(path))\n        else:\n            return\n    # Return if not enough nodes\n    if len(sel) &lt; 1:\n        hou.ui.displayMessage(\"Not enough nodes selected to connect between.\")\n        return\n    node_paths = [x.path() for x in sel]\n    node_paths = '\\n    '.join(node_paths)\n    mods = {\"prefix\":\"\", \"suffix\":\"\", \"replace_from\":\"\", \"replace_to\":\"\"}\n    _set_modifiers(mods)\n    if hou.ui.displayMessage(f\"You're about to connect parms between nodes with the following configuration:\\nMaster node:\\n    {node.path()}\\n\\nNodes referencing from the master node:\\n    {node_paths}\", buttons=(\"Connect Parms\", \"Cancel\")) == 0:\n        sel.append(node)\n        print(sel)\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.modify_conditionals","title":"<code>modify_conditionals(conditionals, templates, ref_template_dict, created_by_conditionals=None, prefix='', suffix='', replacefrom='', replaceto='', include_only=None, exclude=None, mod_all_conditionals=True)</code>","text":"<p>Process and update parameter conditional expressions.</p> <p>Analyzes and modifies conditional expressions in parameter templates, handling parameter references and maintaining relationships.</p> <p>Parameters:</p> Name Type Description Default <code>conditionals</code> <code>Dict[parmCondType, str]</code> <p>Dictionary of conditional expressions</p> required <code>templates</code> <code>Union[List[ParmTemplate], List[str]]</code> <p>List of templates or parameter names to process</p> required <code>ref_template_dict</code> <code>Dict[str, ParmTemplate]</code> <p>Dictionary of reference templates</p> required <code>created_by_conditionals</code> <code>Optional[List[ParmTemplate]]</code> <p>List to store templates created by conditionals</p> <code>None</code> <code>prefix</code> <code>str</code> <p>String to prepend to parameter names</p> <code>''</code> <code>suffix</code> <code>str</code> <p>String to append to parameter names</p> <code>''</code> <code>replacefrom</code> <code>str</code> <p>String to replace in parameter names</p> <code>''</code> <code>replaceto</code> <code>str</code> <p>Replacement string for replacefrom</p> <code>''</code> <code>include_only</code> <code>Optional[List[str]]</code> <p>List of parameter names to include</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>List of parameter names to exclude</p> <code>None</code> <code>mod_all_conditionals</code> <code>bool</code> <p>Whether to modify all expressions</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[parmCondType, str]</code> <p>Dictionary of updated conditional expressions</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conds = {hou.parmCondType.DisableWhen: \"param1 == 0\"}\n&gt;&gt;&gt; modified = modify_conditionals(conds, templates, ref_dict,\n...     prefix=\"new_\",\n...     mod_all_conditionals=True)\n&gt;&gt;&gt; print(modified[hou.parmCondType.DisableWhen])\n'new_param1 == 0'\n</code></pre> Notes <ul> <li>Handles both string names and ParmTemplate objects</li> <li>Updates parameter references in expressions</li> <li>Maintains conditional logic while updating names</li> <li>Adds referenced parameters to template list if needed</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/parameters.py</code> <pre><code>def modify_conditionals(conditionals: Dict[hou.parmCondType, str],\n                       templates: Union[List[hou.ParmTemplate], List[str]],\n                       ref_template_dict: Dict[str, hou.ParmTemplate],\n                       created_by_conditionals: Optional[List[hou.ParmTemplate]] = None,\n                       prefix: str = \"\",\n                       suffix: str = \"\",\n                       replacefrom: str = \"\",\n                       replaceto: str = \"\",\n                       include_only: Optional[List[str]] = None,\n                       exclude: Optional[List[str]] = None,\n                       mod_all_conditionals: bool = True) -&gt; Dict[hou.parmCondType, str]:\n    \"\"\"Process and update parameter conditional expressions.\n\n    Analyzes and modifies conditional expressions in parameter templates,\n    handling parameter references and maintaining relationships.\n\n    Args:\n        conditionals: Dictionary of conditional expressions\n        templates: List of templates or parameter names to process\n        ref_template_dict: Dictionary of reference templates\n        created_by_conditionals: List to store templates created by conditionals\n        prefix: String to prepend to parameter names\n        suffix: String to append to parameter names\n        replacefrom: String to replace in parameter names\n        replaceto: Replacement string for replacefrom\n        include_only: List of parameter names to include\n        exclude: List of parameter names to exclude\n        mod_all_conditionals: Whether to modify all expressions\n\n    Returns:\n        Dictionary of updated conditional expressions\n\n    Examples:\n        &gt;&gt;&gt; conds = {hou.parmCondType.DisableWhen: \"param1 == 0\"}\n        &gt;&gt;&gt; modified = modify_conditionals(conds, templates, ref_dict,\n        ...     prefix=\"new_\",\n        ...     mod_all_conditionals=True)\n        &gt;&gt;&gt; print(modified[hou.parmCondType.DisableWhen])\n        'new_param1 == 0'\n\n    Notes:\n        - Handles both string names and ParmTemplate objects\n        - Updates parameter references in expressions\n        - Maintains conditional logic while updating names\n        - Adds referenced parameters to template list if needed\n\n    Since: 1.0.0\n    \"\"\"\n    include_only = include_only or []\n    exclude = exclude or []\n    def modify_parm(param:str, prefix:str, suffix:str, replacefrom:str, replaceto:str):\n        new_param = f\"{prefix}{param}{suffix}\"\n        if replacefrom and replaceto:\n            new_param = new_param.replace(replacefrom, replaceto)\n        return re.sub(r'\\b{}\\b'.format(param), new_param, new_cond_str)\n    new_conditionals = {}\n    for cond_type, cond_str in conditionals.items():\n        # Extract parameter names from the conditional string\n        param_names = re.findall(r'\\b(\\w+)\\b [!=&lt;&gt;]', cond_str)\n        new_cond_str = cond_str\n\n        for param in param_names:\n            if include_only is None or param in include_only:\n                # Apply modifications to the parameter\n                new_cond_str = modify_parm(param, prefix, suffix, replacefrom, replaceto)\n            else:\n                # Apply modifications to the parameter if mod_all_conditionals is True\n                if mod_all_conditionals:\n                    new_cond_str = modify_parm(param, prefix, suffix, replacefrom, replaceto)\n                # Add parameter to templates if not in include_only list\n                if len(templates) &gt; 0:\n                    if param in exclude:\n                        continue\n                    # Search wildcard exclusions\n                    found = False\n                    for excl in exclude:\n                        if excl.startswith(\"*\") and excl.endswith(\"*\") and excl[1:-1] in param:\n                            found = True\n                            break\n                    if found:\n                        continue\n                    # For cases when the templates list is a list of strings\n                    if isinstance(templates[0], str):\n                        if param not in templates:\n                            templates.append(param)\n                    # For cases when the templates list is a list of hou.ParmTemplates\n                    else:\n                        if param not in ref_template_dict.keys():\n                            continue\n                        param_template = ref_template_dict[param]\n                        if param_template not in templates \\\n                        and param_template not in created_by_conditionals:\n                            if created_by_conditionals is not None:\n                                created_by_conditionals.append(param_template)\n        new_conditionals[cond_type] = new_cond_str\n\n    return new_conditionals\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.modify_parm_templates","title":"<code>modify_parm_templates(group_or_folder, prefix='', suffix='', replacefrom='', replaceto='', folder_name='', folder_label='', folder_type=hou.folderType.Simple, include_only=None, exclude=None, ref_parmtemplate_dict=None, mod_all_conditionals=True, created_by_conditionals=None)</code>","text":"<p>Modify parameter templates with consistent naming and organization.</p> <p>Processes a parameter template group or folder to modify parameter names and organization while preserving parameter relationships and functionality.</p> <p>Parameters:</p> Name Type Description Default <code>group_or_folder</code> <code>Union[ParmTemplateGroup, FolderParmTemplate]</code> <p>Template group or folder to process</p> required <code>prefix</code> <code>str</code> <p>String to prepend to parameter names</p> <code>''</code> <code>suffix</code> <code>str</code> <p>String to append to parameter names</p> <code>''</code> <code>replacefrom</code> <code>str</code> <p>String to replace in parameter names</p> <code>''</code> <code>replaceto</code> <code>str</code> <p>Replacement string for replacefrom</p> <code>''</code> <code>folder_name</code> <code>str</code> <p>Name for the containing folder</p> <code>''</code> <code>folder_label</code> <code>str</code> <p>Display label for the folder</p> <code>''</code> <code>folder_type</code> <code>folderType</code> <p>Type of folder to create</p> <code>Simple</code> <code>include_only</code> <code>Optional[List[str]]</code> <p>List of parameter names to include (None = all)</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>List of parameter names to exclude</p> <code>None</code> <code>ref_parmtemplate_dict</code> <code>Optional[Dict[str, ParmTemplate]]</code> <p>Dictionary of reference templates</p> <code>None</code> <code>mod_all_conditionals</code> <code>bool</code> <p>Whether to modify all conditional expressions</p> <code>True</code> <code>created_by_conditionals</code> <code>Optional[list]</code> <p>List to store templates created by conditionals</p> <code>None</code> <p>Returns:</p> Type Description <code>FolderParmTemplate</code> <p>Modified folder containing processed parameter templates</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If folder_name or folder_label not provided</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic parameter renaming\n&gt;&gt;&gt; templates = node.parmTemplateGroup()\n&gt;&gt;&gt; modified = modify_parm_templates(templates,\n...     prefix=\"mat_\",\n...     folder_name=\"material_params\",\n...     folder_label=\"Material Parameters\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Complex filtering and modification\n&gt;&gt;&gt; modified = modify_parm_templates(templates,\n...     prefix=\"shader_\",\n...     include_only=[\"diffuse\", \"specular\"],\n...     exclude=[\"*_old\"],\n...     mod_all_conditionals=True)\n</code></pre> Notes <ul> <li>Parameters in conditionals are handled specially:<ul> <li>Referenced parameters are added even if not in include_only</li> <li>Conditional expressions are updated to match naming changes</li> </ul> </li> <li>Exclusion patterns with * are treated as wildcards</li> <li>Parameter references and relationships are maintained</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/parameters.py</code> <pre><code>def modify_parm_templates(group_or_folder: Union[hou.ParmTemplateGroup, hou.FolderParmTemplate],\n                        prefix: str = \"\",\n                        suffix: str = \"\",\n                        replacefrom: str = \"\",\n                        replaceto: str = \"\",\n                        folder_name: str = \"\",\n                        folder_label: str = \"\",\n                        folder_type: hou.folderType = hou.folderType.Simple,\n                        include_only: Optional[List[str]] = None,\n                        exclude: Optional[List[str]] = None,\n                        ref_parmtemplate_dict: Optional[Dict[str, hou.ParmTemplate]] = None,\n                        mod_all_conditionals: bool = True,\n                        created_by_conditionals: Optional[list] = None) -&gt; hou.FolderParmTemplate:\n    \"\"\"Modify parameter templates with consistent naming and organization.\n\n    Processes a parameter template group or folder to modify parameter names and\n    organization while preserving parameter relationships and functionality.\n\n    Args:\n        group_or_folder: Template group or folder to process\n        prefix: String to prepend to parameter names\n        suffix: String to append to parameter names\n        replacefrom: String to replace in parameter names\n        replaceto: Replacement string for replacefrom\n        folder_name: Name for the containing folder\n        folder_label: Display label for the folder\n        folder_type: Type of folder to create\n        include_only: List of parameter names to include (None = all)\n        exclude: List of parameter names to exclude\n        ref_parmtemplate_dict: Dictionary of reference templates\n        mod_all_conditionals: Whether to modify all conditional expressions\n        created_by_conditionals: List to store templates created by conditionals\n\n    Returns:\n        Modified folder containing processed parameter templates\n\n    Raises:\n        ValueError: If folder_name or folder_label not provided\n\n    Examples:\n        &gt;&gt;&gt; # Basic parameter renaming\n        &gt;&gt;&gt; templates = node.parmTemplateGroup()\n        &gt;&gt;&gt; modified = modify_parm_templates(templates,\n        ...     prefix=\"mat_\",\n        ...     folder_name=\"material_params\",\n        ...     folder_label=\"Material Parameters\")\n\n        &gt;&gt;&gt; # Complex filtering and modification\n        &gt;&gt;&gt; modified = modify_parm_templates(templates,\n        ...     prefix=\"shader_\",\n        ...     include_only=[\"diffuse\", \"specular\"],\n        ...     exclude=[\"*_old\"],\n        ...     mod_all_conditionals=True)\n\n    Notes:\n        - Parameters in conditionals are handled specially:\n            - Referenced parameters are added even if not in include_only\n            - Conditional expressions are updated to match naming changes\n        - Exclusion patterns with * are treated as wildcards\n        - Parameter references and relationships are maintained\n\n    Since: 1.0.0\n    \"\"\"\n    templates = []\n    created_by_conditionals = created_by_conditionals or []\n    include_only = include_only or []\n    exclude = exclude or []\n    # Creates a dictionary of parmTemplates for reference. This is passed forward from here on.\n    if ref_parmtemplate_dict is None:\n        ref_parmtemplate_dict = {t.name(): t for t in all_parm_templates(group_or_folder)}\n\n    if folder_name == \"\" or folder_label == \"\":\n        print(\"Folder name and label must be defined for the folder to be created.\")\n        return\n\n    excl_wildcards = [excl[1:-1] for excl in exclude if excl.startswith(\"*\") and excl.endswith(\"*\")]\n\n    for parm_template in group_or_folder.parmTemplates():\n        if include_only is not None \\\n        and parm_template.name() not in include_only \\\n        and parm_template.type() != hou.parmTemplateType.Folder:\n            continue\n        if exclude is not None \\\n        and parm_template.type() != hou.parmTemplateType.Folder:\n            if parm_template.name() in exclude:\n                continue\n            for excl in excl_wildcards:\n                if excl in parm_template.name():\n                    continue\n\n        new_name = prefix+parm_template.name().replace(replacefrom, replaceto)+suffix\n        parm_template.setName(new_name)\n\n        # Deal with conditional statements.\n        if parm_template.conditionals():\n            new_cond = modify_conditionals(parm_template.conditionals(), templates, ref_parmtemplate_dict, created_by_conditionals, prefix, suffix, replacefrom, replaceto, include_only, exclude, mod_all_conditionals=mod_all_conditionals)\n            for cond_type, cond_str in new_cond.items():\n                parm_template.setConditional(cond_type, cond_str)\n\n        # Adjust parms that were created by conditional statements\n        for created_parm in created_by_conditionals:\n            created_parm.setName(prefix+created_parm.name().replace(replacefrom, replaceto)+suffix)\n            templates.append(created_parm)\n        created_by_conditionals.clear()\n\n        # Note that we don't want to return parm templates inside multiparm\n        # blocks, so we verify that the folder parm template is actually\n        # for a folder.\n        if parm_template.type() == hou.parmTemplateType.Folder and parm_template.isActualFolder():\n            templates.append(modify_parm_templates(parm_template, prefix, suffix, replacefrom, replaceto, folder_name=parm_template.name(), folder_label=parm_template.label(), folder_type=parm_template.folderType(), include_only=include_only, exclude=exclude, ref_parmtemplate_dict=ref_parmtemplate_dict, mod_all_conditionals=mod_all_conditionals, created_by_conditionals=created_by_conditionals))\n        else:\n            templates.append(parm_template)\n    return hou.FolderParmTemplate(folder_name, folder_label, templates, folder_type)\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.relative_reference_multiparm","title":"<code>relative_reference_multiparm(source_node, target_node, target_mparm_name, parm_name_dict, start_index=1)</code>","text":"<p>Connect source parameters to destination parameters in a multiparm block.</p> <p>Creates relative references between source and destination parameters and ensures new multiparm entries maintain these connections.</p> <p>Parameters:</p> Name Type Description Default <code>source_node</code> <code>Node</code> <p>Node containing source parameters</p> required <code>target_node</code> <code>Node</code> <p>Node containing target multiparm block</p> required <code>target_mparm_name</code> <code>str</code> <p>Name of the multiparm parameter</p> required <code>parm_name_dict</code> <code>dict</code> <p>Mapping of source to destination parameter names. Format: {\"source_parm#\": \"dest_parm#\", \"source_parm2#\": \"dest_parm2#\"}</p> required <code>start_index</code> <code>int</code> <p>Starting index for multiparm. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameters don't exist or are invalid</p> <code>RuntimeError</code> <p>If parameter connections fail</p> Example <p>parms = {\"scale#\": \"instance_scale#\"} relative_reference_multiparm(src, dst, \"num_instances\", parms)</p> Source code in <code>utils/parameters.py</code> <pre><code>def relative_reference_multiparm(source_node:hou.Node,\n                                target_node:hou.Node,\n                                target_mparm_name:str,\n                                parm_name_dict:dict,\n                                start_index:int=1) -&gt; None:\n    \"\"\"Connect source parameters to destination parameters in a multiparm block.\n\n    Creates relative references between source and destination parameters and ensures\n    new multiparm entries maintain these connections.\n\n    Args:\n        source_node (hou.Node): Node containing source parameters\n        target_node (hou.Node): Node containing target multiparm block\n        target_mparm_name (str): Name of the multiparm parameter\n        parm_name_dict (dict): Mapping of source to destination parameter names.\n            Format: {\"source_parm#\": \"dest_parm#\", \"source_parm2#\": \"dest_parm2#\"}\n        start_index (int, optional): Starting index for multiparm. Defaults to 1.\n\n    Raises:\n        ValueError: If parameters don't exist or are invalid\n        RuntimeError: If parameter connections fail\n\n    Example:\n        &gt;&gt;&gt; parms = {\"scale#\": \"instance_scale#\"}\n        &gt;&gt;&gt; relative_reference_multiparm(src, dst, \"num_instances\", parms)\n    \"\"\"\n    # First set the multiparm to connect for every new entry.\n    mparm_connect = f\"opmultiparm {target_node.path()}\"\n    for src_parm, dst_parm in parm_name_dict.items():\n        mparm_connect += f\" '{dst_parm}' '{target_node.relativePathTo(source_node)}/{src_parm}'\"\n    hou.hscript(mparm_connect)\n\n    # Then connect the pre-existing entries. Doesn't yet account for vectors.\n    for i in range(start_index, target_node.evalParm(target_mparm_name)+start_index):\n        for src_parm, dst_parm in parm_name_dict.items():\n            if target_node.parm(f\"{dst_parm[:-1]}{i}\") and source_node.parm(f\"{src_parm[:-1]}{i}\"):\n                target_node.parm(f\"{dst_parm[:-1]}{i}\").deleteAllKeyframes()\n                target_node.parm(f\"{dst_parm[:-1]}{i}\").set(source_node.parm(f\"{src_parm[:-1]}{i}\"))\n</code></pre>"},{"location":"reference/utils/parameters/#utils.parameters.reset_script_parms_to_default","title":"<code>reset_script_parms_to_default(node)</code>","text":"<p>Reset all script parameters to their default values.</p> <p>Resets parameters with script callbacks to their default script values to ensure proper parameter updating behavior.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node containing script parameters to reset</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If node is None or invalid</p> <code>RuntimeError</code> <p>If parameter reset fails</p> Source code in <code>utils/parameters.py</code> <pre><code>def reset_script_parms_to_default(node:hou.Node) -&gt; None:\n    \"\"\"Reset all script parameters to their default values.\n\n    Resets parameters with script callbacks to their default script values to\n    ensure proper parameter updating behavior.\n\n    Args:\n        node (hou.Node): Node containing script parameters to reset\n\n    Raises:\n        ValueError: If node is None or invalid\n        RuntimeError: If parameter reset fails\n    \"\"\"\n    for parm in node.parms():\n        template = parm.parmTemplate()\n        if template.type() in (hou.parmTemplateType.Int, hou.parmTemplateType.Float, hou.parmTemplateType.String, hou.parmTemplateType.Toggle, hou.parmTemplateType.Menu):\n            # For non-string parms\n            if template.defaultExpressionLanguage() == hou.scriptLanguage.Python \\\n            or template.defaultExpressionLanguage() == (hou.scriptLanguage.Python,):\n                try:\n                    parm.setKeyframe(hou.Keyframe())\n                except TypeError:\n                    parm.setKeyframe(hou.StringKeyframe())\n                parm.deleteAllKeyframes()\n                parm.revertToDefaults()\n</code></pre>"},{"location":"reference/utils/qt/","title":"qt.py","text":"<p>Enhanced Qt components and patterns for consistent UI implementation.</p> <p>This module provides a comprehensive set of base classes, mixins, and utilities for building Qt interfaces in Houdini. It focuses on: - Consistent styling and theming - Reusable UI patterns - Type-safe signal/slot connections - State management - Resource handling</p>"},{"location":"reference/utils/qt/#utils.qt.BaseWidget","title":"<code>BaseWidget</code>","text":"<p>               Bases: <code>QWidget</code>, <code>WindowMixin</code>, <code>DialogMixin</code></p> <p>Base widget with common functionality.</p> Source code in <code>utils/qt.py</code> <pre><code>class BaseWidget(QtWidgets.QWidget, WindowMixin, DialogMixin):\n    \"\"\"Base widget with common functionality.\"\"\"\n\n    theme_manager = ThemeManager()\n\n    def __init__(self, parent: Optional[QtWidgets.QWidget] = None):\n        super().__init__(parent)\n        self.setup_ui()\n        self.theme_manager.apply_theme(self)\n\n    def setup_ui(self) -&gt; None:\n        \"\"\"Set up the widget's UI.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.BaseWidget.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Set up the widget's UI.</p> Source code in <code>utils/qt.py</code> <pre><code>def setup_ui(self) -&gt; None:\n    \"\"\"Set up the widget's UI.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.DialogMixin","title":"<code>DialogMixin</code>","text":"<p>Provides common dialog functionality for widgets.</p> Source code in <code>utils/qt.py</code> <pre><code>class DialogMixin:\n    \"\"\"Provides common dialog functionality for widgets.\"\"\"\n\n    def show_error(self, message: str, title: str = \"Error\") -&gt; None:\n        \"\"\"Show error dialog.\"\"\"\n        QtWidgets.QMessageBox.critical(self, title, message)\n\n    def show_warning(self, message: str, title: str = \"Warning\") -&gt; None:\n        \"\"\"Show warning dialog.\"\"\"\n        QtWidgets.QMessageBox.warning(self, title, message)\n\n    def confirm(self, message: str, title: str = \"Confirm\") -&gt; bool:\n        \"\"\"Show confirmation dialog.\n\n        Returns:\n            True if user confirmed, False otherwise\n        \"\"\"\n        return QtWidgets.QMessageBox.question(\n            self, title, message,\n            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No\n        ) == QtWidgets.QMessageBox.Yes\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.DialogMixin.confirm","title":"<code>confirm(message, title='Confirm')</code>","text":"<p>Show confirmation dialog.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if user confirmed, False otherwise</p> Source code in <code>utils/qt.py</code> <pre><code>def confirm(self, message: str, title: str = \"Confirm\") -&gt; bool:\n    \"\"\"Show confirmation dialog.\n\n    Returns:\n        True if user confirmed, False otherwise\n    \"\"\"\n    return QtWidgets.QMessageBox.question(\n        self, title, message,\n        QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No\n    ) == QtWidgets.QMessageBox.Yes\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.DialogMixin.show_error","title":"<code>show_error(message, title='Error')</code>","text":"<p>Show error dialog.</p> Source code in <code>utils/qt.py</code> <pre><code>def show_error(self, message: str, title: str = \"Error\") -&gt; None:\n    \"\"\"Show error dialog.\"\"\"\n    QtWidgets.QMessageBox.critical(self, title, message)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.DialogMixin.show_warning","title":"<code>show_warning(message, title='Warning')</code>","text":"<p>Show warning dialog.</p> Source code in <code>utils/qt.py</code> <pre><code>def show_warning(self, message: str, title: str = \"Warning\") -&gt; None:\n    \"\"\"Show warning dialog.\"\"\"\n    QtWidgets.QMessageBox.warning(self, title, message)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.ResultsList","title":"<code>ResultsList</code>","text":"<p>               Bases: <code>BaseWidget</code></p> <p>Reusable widget for displaying search/operation results.</p> Source code in <code>utils/qt.py</code> <pre><code>class ResultsList(BaseWidget):\n    \"\"\"Reusable widget for displaying search/operation results.\"\"\"\n\n    item_selected = Signal(dict)  # Emitted when user selects a result\n\n    def __init__(self, parent: Optional[QtWidgets.QWidget] = None):\n        super().__init__(parent)\n\n    def setup_ui(self) -&gt; None:\n        layout = QtWidgets.QVBoxLayout(self)\n\n        self.list_widget = QtWidgets.QListWidget()\n        self.list_widget.itemClicked.connect(self._on_item_clicked)\n\n        self.status_label = QtWidgets.QLabel()\n\n        layout.addWidget(self.status_label)\n        layout.addWidget(self.list_widget)\n\n    def set_results(self, results: List[Dict[str, Any]]) -&gt; None:\n        \"\"\"Update displayed results.\"\"\"\n        self.list_widget.clear()\n        self.status_label.setText(f\"Found {len(results)} results\")\n\n        for result in results:\n            item = QtWidgets.QListWidgetItem()\n            item.setText(result[\"display_text\"])\n            item.setData(Qt.UserRole, result)\n            self.list_widget.addItem(item)\n\n    @Slot(QtWidgets.QListWidgetItem)\n    def _on_item_clicked(self, item: QtWidgets.QListWidgetItem) -&gt; None:\n        \"\"\"Handle result selection.\"\"\"\n        result_data = item.data(Qt.UserRole)\n        self.item_selected.emit(result_data)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.ResultsList.set_results","title":"<code>set_results(results)</code>","text":"<p>Update displayed results.</p> Source code in <code>utils/qt.py</code> <pre><code>def set_results(self, results: List[Dict[str, Any]]) -&gt; None:\n    \"\"\"Update displayed results.\"\"\"\n    self.list_widget.clear()\n    self.status_label.setText(f\"Found {len(results)} results\")\n\n    for result in results:\n        item = QtWidgets.QListWidgetItem()\n        item.setText(result[\"display_text\"])\n        item.setData(Qt.UserRole, result)\n        self.list_widget.addItem(item)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.SearchWidget","title":"<code>SearchWidget</code>","text":"<p>               Bases: <code>BaseWidget</code></p> <p>Reusable search widget with common functionality.</p> Source code in <code>utils/qt.py</code> <pre><code>class SearchWidget(BaseWidget):\n    \"\"\"Reusable search widget with common functionality.\"\"\"\n\n    search_triggered = Signal(str)  # Emitted when search should be performed\n\n    def __init__(self, parent: Optional[QtWidgets.QWidget] = None):\n        super().__init__(parent)\n\n    def setup_ui(self) -&gt; None:\n        layout = QtWidgets.QHBoxLayout(self)\n\n        self.search_input = QtWidgets.QLineEdit()\n        self.search_input.setPlaceholderText(\"Search...\")\n        self.search_input.textChanged.connect(self._on_text_changed)\n\n        self.case_sensitive = QtWidgets.QCheckBox(\"Case Sensitive\")\n\n        layout.addWidget(self.search_input)\n        layout.addWidget(self.case_sensitive)\n\n    @Slot(str)\n    def _on_text_changed(self, text: str) -&gt; None:\n        \"\"\"Handle search text changes.\"\"\"\n        if len(text) &gt;= 3:  # Minimum search length\n            self.search_triggered.emit(text)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.ThemeManager","title":"<code>ThemeManager</code>","text":"<p>Manages application-wide theming and styling.</p> <p>Uses a configuration-driven approach to maintain consistent visual styling across the application.</p> Source code in <code>utils/qt.py</code> <pre><code>class ThemeManager:\n    \"\"\"Manages application-wide theming and styling.\n\n    Uses a configuration-driven approach to maintain consistent visual styling\n    across the application.\n    \"\"\"\n\n    def __init__(self):\n        self._current_theme = \"dark\"\n        self._themes: Dict[str, Dict[str, str]] = {\n            \"dark\": {\n                \"primary\": \"#2B5B84\",\n                \"secondary\": \"#538cc6\",\n                \"background\": \"#2b2b2b\",\n                \"surface\": \"#333333\",\n                \"error\": \"#cf6679\",\n                \"text\": \"#ffffff\",\n                \"border\": \"#444444\"\n            },\n            \"light\": {\n                \"primary\": \"#1976d2\",\n                \"secondary\": \"#42a5f5\",\n                \"background\": \"#fafafa\",\n                \"surface\": \"#ffffff\",\n                \"error\": \"#b00020\",\n                \"text\": \"#000000\",\n                \"border\": \"#e0e0e0\"\n            }\n        }\n\n    def get_color(self, name: str) -&gt; str:\n        \"\"\"Get color value from current theme.\"\"\"\n        return self._themes[self._current_theme][name]\n\n    def apply_theme(self, widget: QtWidgets.QWidget) -&gt; None:\n        \"\"\"Apply current theme to widget and all children.\"\"\"\n        theme = self._themes[self._current_theme]\n        widget.setStyleSheet(f\"\"\"\n            QWidget {{\n                background-color: {theme[\"background\"]};\n                color: {theme[\"text\"]};\n                font-size: 12px;\n            }}\n\n            QPushButton {{\n                background-color: {theme[\"primary\"]};\n                border: none;\n                padding: 8px 16px;\n                border-radius: 4px;\n            }}\n\n            QPushButton:hover {{\n                background-color: {theme[\"secondary\"]};\n            }}\n\n            QLineEdit {{\n                padding: 8px;\n                border: 1px solid {theme[\"border\"]};\n                border-radius: 4px;\n                background-color: {theme[\"surface\"]};\n            }}\n\n            QComboBox {{\n                padding: 8px;\n                border: 1px solid {theme[\"border\"]};\n                border-radius: 4px;\n                background-color: {theme[\"surface\"]};\n            }}\n        \"\"\")\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.ThemeManager.apply_theme","title":"<code>apply_theme(widget)</code>","text":"<p>Apply current theme to widget and all children.</p> Source code in <code>utils/qt.py</code> <pre><code>def apply_theme(self, widget: QtWidgets.QWidget) -&gt; None:\n    \"\"\"Apply current theme to widget and all children.\"\"\"\n    theme = self._themes[self._current_theme]\n    widget.setStyleSheet(f\"\"\"\n        QWidget {{\n            background-color: {theme[\"background\"]};\n            color: {theme[\"text\"]};\n            font-size: 12px;\n        }}\n\n        QPushButton {{\n            background-color: {theme[\"primary\"]};\n            border: none;\n            padding: 8px 16px;\n            border-radius: 4px;\n        }}\n\n        QPushButton:hover {{\n            background-color: {theme[\"secondary\"]};\n        }}\n\n        QLineEdit {{\n            padding: 8px;\n            border: 1px solid {theme[\"border\"]};\n            border-radius: 4px;\n            background-color: {theme[\"surface\"]};\n        }}\n\n        QComboBox {{\n            padding: 8px;\n            border: 1px solid {theme[\"border\"]};\n            border-radius: 4px;\n            background-color: {theme[\"surface\"]};\n        }}\n    \"\"\")\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.ThemeManager.get_color","title":"<code>get_color(name)</code>","text":"<p>Get color value from current theme.</p> Source code in <code>utils/qt.py</code> <pre><code>def get_color(self, name: str) -&gt; str:\n    \"\"\"Get color value from current theme.\"\"\"\n    return self._themes[self._current_theme][name]\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.WindowMixin","title":"<code>WindowMixin</code>","text":"<p>Provides window management functionality.</p> Source code in <code>utils/qt.py</code> <pre><code>class WindowMixin:\n    \"\"\"Provides window management functionality.\"\"\"\n\n    def center_on_screen(self) -&gt; None:\n        \"\"\"Center window on screen.\"\"\"\n        screen = QtWidgets.QDesktopWidget().screenGeometry()\n        size = self.geometry()\n        x = (screen.width() - size.width()) // 2\n        y = (screen.height() - size.height()) // 2\n        self.move(x, y)\n\n    def make_stay_on_top(self) -&gt; None:\n        \"\"\"Make window stay on top.\"\"\"\n        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)\n\n    @contextlib.contextmanager\n    def block_signals(self):\n        \"\"\"Temporarily block widget signals.\"\"\"\n        self.blockSignals(True)\n        try:\n            yield\n        finally:\n            self.blockSignals(False)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.WindowMixin.block_signals","title":"<code>block_signals()</code>","text":"<p>Temporarily block widget signals.</p> Source code in <code>utils/qt.py</code> <pre><code>@contextlib.contextmanager\ndef block_signals(self):\n    \"\"\"Temporarily block widget signals.\"\"\"\n    self.blockSignals(True)\n    try:\n        yield\n    finally:\n        self.blockSignals(False)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.WindowMixin.center_on_screen","title":"<code>center_on_screen()</code>","text":"<p>Center window on screen.</p> Source code in <code>utils/qt.py</code> <pre><code>def center_on_screen(self) -&gt; None:\n    \"\"\"Center window on screen.\"\"\"\n    screen = QtWidgets.QDesktopWidget().screenGeometry()\n    size = self.geometry()\n    x = (screen.width() - size.width()) // 2\n    y = (screen.height() - size.height()) // 2\n    self.move(x, y)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.WindowMixin.make_stay_on_top","title":"<code>make_stay_on_top()</code>","text":"<p>Make window stay on top.</p> Source code in <code>utils/qt.py</code> <pre><code>def make_stay_on_top(self) -&gt; None:\n    \"\"\"Make window stay on top.\"\"\"\n    self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)\n</code></pre>"},{"location":"reference/utils/qt/#utils.qt.create_widget_with_layout","title":"<code>create_widget_with_layout(widget_type, layout_type, parent=None)</code>","text":"<p>Create a widget with a layout in one step.</p> Source code in <code>utils/qt.py</code> <pre><code>def create_widget_with_layout(\n    widget_type: Type[W],\n    layout_type: Type[QtWidgets.QLayout],\n    parent: Optional[QtWidgets.QWidget] = None\n) -&gt; W:\n    \"\"\"Create a widget with a layout in one step.\"\"\"\n    widget = widget_type(parent)\n    layout = layout_type(widget)\n    widget.setLayout(layout)\n    return widget\n</code></pre>"},{"location":"reference/utils/strings/","title":"strings.py","text":"<p>String manipulation utilities for NodeWeaver.</p> <p>This module provides comprehensive string manipulation utilities focused on handling Houdini-specific string operations, path management, and object representation. It includes functions for sanitization, case conversion, tree visualization, and detailed object inspection.</p> <p>Functions:</p> Name Description <code>sanitize_string</code> <p>Clean strings with custom transformations</p> <code>fix_slash</code> <p>Replace backslashes with forward slashes</p> <code>fix_periods</code> <p>Replace periods with underscores</p> <code>clean_posix_path</code> <p>Normalize and validate POSIX paths</p> <code>is_camelcase</code> <p>Check if string follows camelCase format</p> <code>to_camelcase</code> <p>Convert string to camelCase format</p> <code>to_titlecase</code> <p>Convert string to Title Case format</p> <code>camelcase_path</code> <p>Convert path components to camelCase</p> <code>tree_from_string_list</code> <p>Create tree visualization from path strings</p> <code>to_digits</code> <p>Extract only digits from a string</p> <code>print_dict</code> <p>Print nested dictionary structures with formatting</p> <code>comprehensive_repr</code> <p>Generate detailed object representations</p>"},{"location":"reference/utils/strings/#utils.strings.camelcase_path","title":"<code>camelcase_path(path)</code>","text":"<p>Convert a full path to camelCase while preserving slashes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path string to convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path with each component converted to camelCase</p> Source code in <code>utils/strings.py</code> <pre><code>def camelcase_path(path: str) -&gt; str:\n    \"\"\"Convert a full path to camelCase while preserving slashes.\n\n    Args:\n        path (str): Path string to convert\n\n    Returns:\n        str: Path with each component converted to camelCase\n    \"\"\"\n    return '/'.join(to_camelcase(part) for part in path.split('/'))\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.clean_posix_path","title":"<code>clean_posix_path(path)</code>","text":"<p>Clean and normalize a path to POSIX format.</p> <p>Removes invalid characters, normalizes slashes, and resolves relative paths.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to clean and normalize</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cleaned POSIX-style path</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If path contains invalid characters</p> Source code in <code>utils/strings.py</code> <pre><code>def clean_posix_path(path: str) -&gt; str:\n    \"\"\"Clean and normalize a path to POSIX format.\n\n    Removes invalid characters, normalizes slashes, and resolves relative paths.\n\n    Args:\n        path (str): The path to clean and normalize\n\n    Returns:\n        str: Cleaned POSIX-style path\n\n    Raises:\n        ValueError: If path contains invalid characters\n    \"\"\"\n    path = re.sub(r'[&lt;&gt;:\"|?*\\s]', '', path.replace('\\\\', '/'))\n    path = re.sub(r'/+', '/', path)\n    components = [c for c in path.split('/') if c and c != '.']\n    stack = []\n    for c in components:\n        if c == '..' and stack and stack[-1] != '..':\n            stack.pop()\n        else:\n            stack.append(c)\n    clean = '/'.join(stack)\n    return f\"/{clean}\" if path.startswith('/') else clean or '.'\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.comprehensive_repr","title":"<code>comprehensive_repr(obj, exclude=None, prioritize=None, include_private=False, include_callable=False, sort_keys=False, max_length=None, one_per_line=False, filter_func=None, _depth=0, _visited=None)</code>","text":"<p>Generate a comprehensive string representation of an object.</p> <p>Creates a detailed string representation of an object, with extensive customization options for controlling output format and content.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to represent</p> required <code>exclude</code> <code>Optional[List[str]]</code> <p>Attributes to exclude from representation</p> <code>None</code> <code>prioritize</code> <code>Optional[List[str]]</code> <p>Attributes to list first in representation</p> <code>None</code> <code>include_private</code> <code>bool</code> <p>Include attributes starting with underscore</p> <code>False</code> <code>include_callable</code> <code>bool</code> <p>Include methods and other callable attributes</p> <code>False</code> <code>sort_keys</code> <code>bool</code> <p>Sort attributes alphabetically</p> <code>False</code> <code>max_length</code> <code>Optional[int]</code> <p>Truncate result to this length</p> <code>None</code> <code>one_per_line</code> <code>bool</code> <p>Put each attribute on a new line</p> <code>False</code> <code>filter_func</code> <code>Optional[Callable[[str, Any], bool]]</code> <p>Custom function to filter attributes</p> <code>None</code> <code>_depth</code> <code>int</code> <p>Internal parameter tracking recursion depth</p> <code>0</code> <code>_visited</code> <code>Optional[set]</code> <p>Internal set tracking visited objects</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string representation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Example:\n...     def __init__(self):\n...         self.a = 1\n...         self.b = \"test\"\n</code></pre> <pre><code>&gt;&gt;&gt; print(comprehensive_repr(Example(), one_per_line=True))\nExample(\n    a=1\n    b=\"test\"\n)\n</code></pre> <pre><code>&gt;&gt;&gt; # Exclude specific attributes\n&gt;&gt;&gt; print(comprehensive_repr(Example(), exclude=['b']))\nExample(a=1)\n</code></pre> Notes <ul> <li>Handles recursive structures safely</li> <li>Provides cycle detection</li> <li>Supports custom filtering and formatting</li> <li>Preserves type information</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/strings.py</code> <pre><code>def comprehensive_repr(obj: Any,\n                        exclude: Optional[List[str]] = None,\n                        prioritize: Optional[List[str]] = None,\n                        include_private: bool = False,\n                        include_callable: bool = False,\n                        sort_keys: bool = False,\n                        max_length: Optional[int] = None,\n                        one_per_line: bool = False,\n                        filter_func: Optional[Callable[[str, Any], bool]] = None,\n                        _depth: int = 0,\n                        _visited: Optional[set] = None) -&gt; str:\n    \"\"\"Generate a comprehensive string representation of an object.\n\n    Creates a detailed string representation of an object, with extensive\n    customization options for controlling output format and content.\n\n    Args:\n        obj: The object to represent\n        exclude: Attributes to exclude from representation\n        prioritize: Attributes to list first in representation\n        include_private: Include attributes starting with underscore\n        include_callable: Include methods and other callable attributes\n        sort_keys: Sort attributes alphabetically\n        max_length: Truncate result to this length\n        one_per_line: Put each attribute on a new line\n        filter_func: Custom function to filter attributes\n        _depth: Internal parameter tracking recursion depth\n        _visited: Internal set tracking visited objects\n\n    Returns:\n        Formatted string representation\n\n    Examples:\n        &gt;&gt;&gt; class Example:\n        ...     def __init__(self):\n        ...         self.a = 1\n        ...         self.b = \"test\"\n\n        &gt;&gt;&gt; print(comprehensive_repr(Example(), one_per_line=True))\n        Example(\n            a=1\n            b=\"test\"\n        )\n\n        &gt;&gt;&gt; # Exclude specific attributes\n        &gt;&gt;&gt; print(comprehensive_repr(Example(), exclude=['b']))\n        Example(a=1)\n\n    Notes:\n        - Handles recursive structures safely\n        - Provides cycle detection\n        - Supports custom filtering and formatting\n        - Preserves type information\n\n    Since: 1.0.0\n    \"\"\"\n    if _visited is None:\n        _visited = set()\n    if _depth &gt; sys.getrecursionlimit() // 2 or id(obj) in _visited:\n        return f\"{obj.__class__.__name__}(...)\"\n    _visited.add(id(obj))\n\n    exclude = exclude or []\n    prioritize = prioritize or []\n    attributes = []\n    indent = \"    \" * (_depth + 1) if one_per_line else \"\"\n    joiner = f\"\\n{indent}\" if one_per_line else \", \"\n    starter = f\"\\n{indent}\" if one_per_line else \"\"\n\n    def _indent_repr(repr_str: str, depth: int) -&gt; str:\n        if not one_per_line or '\\n' not in repr_str:\n            return repr_str\n        lines = repr_str.split('\\n')\n        indented_lines = [lines[0]] + [f\"{'    ' * (depth + 1)}{line}\" for line in lines[1:]]\n        return '\\n'.join(indented_lines)\n\n    def _dict_repr(d: dict, depth: int) -&gt; str:\n        if not d:\n            return \"{}\"\n        items = []\n        inner_indent = \"    \" * (depth + 2) if one_per_line else \"\"\n        for k, v in d.items():\n            if isinstance(v, dict):\n                v_repr = _dict_repr(v, depth + 1)\n            elif hasattr(v, '__repr__') and v.__repr__ is not object.__repr__:\n                v_repr = _indent_repr(repr(v), depth + 1)\n            elif hasattr(v, '__dict__'):\n                v_repr = comprehensive_repr(v, exclude, prioritize, include_private, include_callable,\n                                        sort_keys, None, one_per_line, filter_func, depth + 2, _visited.copy())\n            else:\n                v_repr = repr(v)\n            items.append(f\"{inner_indent}{repr(k)}: {v_repr}\")\n        if one_per_line:\n            return \"{\\n\" + \",\\n\".join(items) + f\"\\n{'    ' * (depth + 1)}}}\"\n        else:\n            return \"{\" + \", \".join(items) + \"}\"\n\n    def _handler(value: Any, depth: int):\n        # Handle different types of values\n        if isinstance(value, dict):\n            return _dict_repr(value, depth)\n        elif hasattr(value, '__repr__') and value.__repr__ is not object.__repr__:\n            return _indent_repr(repr(value), depth)\n        elif hasattr(value, '__dict__'):\n            return comprehensive_repr(value, exclude, prioritize, include_private, include_callable,\n                                    sort_keys, None, one_per_line, filter_func, depth + 1, _visited.copy())\n        else:\n            return repr(value)\n\n    def _get_attributes(obj):\n        if hasattr(obj, '__dict__'):\n            return vars(obj).items()\n        elif hasattr(obj, '__slots__'):\n            return ((attr, getattr(obj, attr)) for attr in obj.__slots__ if hasattr(obj, attr))\n        else:\n            return ((attr, getattr(obj, attr)) for attr in dir(obj) if not attr.startswith('__'))\n\n    for attr in prioritize:\n        if hasattr(obj, attr) and attr not in exclude:\n            value = getattr(obj, attr)\n            value_repr = _handler(value, _depth)\n            attributes.append(f\"{attr}={value_repr}\")\n\n    for key, value in _get_attributes(obj):\n        if key in prioritize or key in exclude:\n            continue\n        if not include_private and key.startswith('_'):\n            continue\n        if not include_callable and callable(value):\n            continue\n        if filter_func and not filter_func(key, value):\n            continue\n\n        value_repr = _handler(value, _depth)\n        attributes.append(f\"{key}={value_repr}\")\n\n    if sort_keys:\n        attributes.sort()\n    class_name = obj.__class__.__name__\n    content = joiner.join(attributes)\n\n    if one_per_line:\n        result = f\"{class_name}({starter}{content}\\n{'    ' * _depth})\"\n    else:\n        result = f\"{class_name}({content})\"\n    if max_length and len(result) &gt; max_length:\n        result = result[:max_length-3] + \"...\"\n\n    if len(exclude) &gt; 0:\n        excluded_str = \", \".join(exclude)\n        if one_per_line:\n            result += f\"\\n{'    ' * _depth}# Excluded attributes ({class_name}): {excluded_str}\\n\"\n        else:\n            result += f\" # Excluded attributes ({class_name}): {excluded_str}\"\n\n    return result\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.fix_periods","title":"<code>fix_periods(s)</code>","text":"<p>Replace periods with underscores in a string.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string containing periods to fix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with periods replaced by underscores</p> Source code in <code>utils/strings.py</code> <pre><code>def fix_periods(s: str) -&gt; str:\n    \"\"\"Replace periods with underscores in a string.\n\n    Args:\n        s (str): Input string containing periods to fix\n\n    Returns:\n        str: String with periods replaced by underscores\n    \"\"\"\n    return s.replace(\".\", \"_\")\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.fix_slash","title":"<code>fix_slash(s)</code>","text":"<p>Replace backslashes with forward slashes in a string.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string containing slashes to fix</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with backslashes replaced by forward slashes</p> Source code in <code>utils/strings.py</code> <pre><code>def fix_slash(s: str) -&gt; str:\n    \"\"\"Replace backslashes with forward slashes in a string.\n\n    Args:\n        s (str): Input string containing slashes to fix\n\n    Returns:\n        str: String with backslashes replaced by forward slashes\n    \"\"\"\n    return s.replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.is_camelcase","title":"<code>is_camelcase(s)</code>","text":"<p>Check if a string is in camelCase format.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if string is camelCase, False otherwise</p> Source code in <code>utils/strings.py</code> <pre><code>def is_camelcase(s) -&gt; bool:\n    \"\"\"Check if a string is in camelCase format.\n\n    Args:\n        s (str): String to check\n\n    Returns:\n        bool: True if string is camelCase, False otherwise\n    \"\"\"\n    pattern = r'^[a-z]+(?:[A-Z0-9][a-z0-9]*)*$'\n    return bool(re.match(pattern, s))\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.print_dict","title":"<code>print_dict(d, indent=0, is_nested=False)</code>","text":"<p>Print dictionary or list with formatted indentation.</p> <p>Recursively prints dictionaries and lists with proper indentation for nested structures. Handles None values and non-dict/list objects appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary or list to print</p> required <code>indent</code> <code>int</code> <p>Number of spaces to indent. Defaults to 0</p> <code>0</code> <code>is_nested</code> <code>bool</code> <p>Whether this is a nested call. Defaults to False. Used internally for recursive calls.</p> <code>False</code> Example <p>data = {'a': 1, 'b': {'c': 2}} print_dict(data) {   \"a\": 1,   \"b\": {     \"c\": 2,   }, }</p> Source code in <code>utils/strings.py</code> <pre><code>def print_dict(d: dict, indent: int = 0, is_nested: bool = False) -&gt; None:\n    \"\"\"Print dictionary or list with formatted indentation.\n\n    Recursively prints dictionaries and lists with proper indentation for nested\n    structures. Handles None values and non-dict/list objects appropriately.\n\n    Args:\n        d (dict): Dictionary or list to print\n        indent (int, optional): Number of spaces to indent. Defaults to 0\n        is_nested (bool, optional): Whether this is a nested call. Defaults to False.\n            Used internally for recursive calls.\n\n    Example:\n        &gt;&gt;&gt; data = {'a': 1, 'b': {'c': 2}}\n        &gt;&gt;&gt; print_dict(data)\n        {\n          \"a\": 1,\n          \"b\": {\n            \"c\": 2,\n          },\n        }\n    \"\"\"\n    if d is None:\n        print(\"Object is equal to 'None'.\")\n        return\n    if not isinstance(d, (dict, list)) and not is_nested:\n        print(\"Object is not a dictionary or list. Printing as-is.\")\n        print(d)\n        return\n\n    elif isinstance(d, dict):\n        # not is_nested = top level dictionary\n        if not is_nested:\n            print(' ' * indent + '{')\n        for key, value in d.items():\n            if isinstance(value, dict):\n                print(' ' * (indent + 2) + f'\"{key}\": {{')\n                print_dict(value, indent + 4, is_nested=True)\n                print(' ' * (indent + 2) + '},')\n            elif isinstance(value, list):\n                print(' ' * (indent + 2) + f'\"{key}\": [')\n                print_dict(value, indent + 4, is_nested=True)\n                print(' ' * (indent + 2) + '],')\n            else:\n                print(' ' * (indent + 2) + f'\"{key}\": {value},')\n        if not is_nested:\n            print(' ' * indent + '}')\n\n    elif isinstance(d, list):\n        if not is_nested:\n            print(' ' * indent + '[')\n        for value in d:\n            if isinstance(value, dict):\n                print(' ' * (indent + 2) + '{')\n                print_dict(value, indent + 4, is_nested=True)\n                print(' ' * (indent + 2) + '},')\n            elif isinstance(value, list):\n                print(' ' * (indent + 2) + f'[')\n                print_dict(value, indent + 4, is_nested=True)\n                print(' ' * (indent + 2) + '],')\n            else:\n                print(' ' * (indent + 2) + repr(value) + ',')\n        if not is_nested:\n            print(' ' * indent + ']')\n\n    else:\n        print(' ' * indent + repr(d))\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.sanitize_string","title":"<code>sanitize_string(s, transformations=None)</code>","text":"<p>Apply a series of transformations to sanitize a string.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The input string to sanitize</p> required <code>transformations</code> <code>Optional[List[Callable[[str], str]]]</code> <p>Optional list of functions to apply to the string. Default transformations handle special characters and spaces.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The sanitized string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sanitize_string(\"Hello World!\")\n'Hello_World_'\n</code></pre> <pre><code>&gt;&gt;&gt; # Custom transformations\n&gt;&gt;&gt; transformations = [str.lower, lambda x: x.replace(' ', '-')]\n&gt;&gt;&gt; sanitize_string(\"Hello World!\", transformations)\n'hello-world!'\n</code></pre> Note <p>Default transformations replace: *?:\"&lt;&gt;| and spaces with underscores</p> Source code in <code>utils/strings.py</code> <pre><code>def sanitize_string(s: str, transformations: Optional[List[Callable[[str], str]]] = None) -&gt; str:\n    \"\"\"Apply a series of transformations to sanitize a string.\n\n    Args:\n        s: The input string to sanitize\n        transformations: Optional list of functions to apply to the string.\n            Default transformations handle special characters and spaces.\n\n    Returns:\n        The sanitized string\n\n    Examples:\n        &gt;&gt;&gt; sanitize_string(\"Hello World!\")\n        'Hello_World_'\n\n        &gt;&gt;&gt; # Custom transformations\n        &gt;&gt;&gt; transformations = [str.lower, lambda x: x.replace(' ', '-')]\n        &gt;&gt;&gt; sanitize_string(\"Hello World!\", transformations)\n        'hello-world!'\n\n    Note:\n        Default transformations replace: *?:\"&lt;&gt;| and spaces with underscores\n    \"\"\"\n    default_transformations = [\n        lambda x: re.sub(r'[*?:\"&lt;&gt;| ]', \"_\", x)\n    ]\n\n    all_transformations = default_transformations + (transformations or [])\n\n    return functools.reduce(lambda acc, func: func(acc), all_transformations, s)\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.to_camelcase","title":"<code>to_camelcase(s, check=True)</code>","text":"<p>Convert string to camelCase format.</p> <p>Handles multiple separator types and preserves existing camelCase if check=True.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to convert</p> required <code>check</code> <code>bool</code> <p>Whether to preserve existing camelCase. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in camelCase format</p> Source code in <code>utils/strings.py</code> <pre><code>def to_camelcase(s: str, check: bool = True) -&gt; str:\n    \"\"\"Convert string to camelCase format.\n\n    Handles multiple separator types and preserves existing camelCase if check=True.\n\n    Args:\n        s (str): String to convert\n        check (bool, optional): Whether to preserve existing camelCase. Defaults to True.\n\n    Returns:\n        str: String in camelCase format\n    \"\"\"\n    # Remove asterisks first to prevent empty strings\n    s = s.replace(\"*\", \"\")\n    if not s:\n        return \"\"\n\n    s2 = re.sub(r\"(_|-)+\", \" \", s).title().replace(\" \", \"\")\n    if check and is_camelcase(s):\n        return s\n    elif s2:\n        return ''.join([s2[0].lower(), s2[1:]])\n    else:\n        return \"\"\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.to_digits","title":"<code>to_digits(s)</code>","text":"<p>Convert string to digits by removing all non-digit characters.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string containing digits and other characters</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String containing only the digit characters from input</p> Example <p>to_digits(\"abc123def456\") '123456'</p> Source code in <code>utils/strings.py</code> <pre><code>def to_digits(s: str) -&gt; str:\n    \"\"\"Convert string to digits by removing all non-digit characters.\n\n    Args:\n        s (str): Input string containing digits and other characters\n\n    Returns:\n        str: String containing only the digit characters from input\n\n    Example:\n        &gt;&gt;&gt; to_digits(\"abc123def456\")\n        '123456'\n    \"\"\"\n    s = ''.join(filter(lambda i: i.isdigit(), s))\n    return s\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.to_titlecase","title":"<code>to_titlecase(s)</code>","text":"<p>Convert string to Title Case format.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to convert</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String in Title Case format</p> Source code in <code>utils/strings.py</code> <pre><code>def to_titlecase(s: str) -&gt; str:\n    \"\"\"Convert string to Title Case format.\n\n    Args:\n        s (str): String to convert\n\n    Returns:\n        str: String in Title Case format\n    \"\"\"\n    return ' '.join(word.capitalize() for word in s.replace('_', ' ').split())\n</code></pre>"},{"location":"reference/utils/strings/#utils.strings.tree_from_string_list","title":"<code>tree_from_string_list(paths)</code>","text":"<p>Create a tree visualization from a list of path strings.</p> <p>Converts a list of path strings into an ASCII tree structure representation, showing hierarchical relationships.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>List[str]</code> <p>List of path strings to visualize</p> required <p>Returns:</p> Type Description <code>str</code> <p>String containing ASCII tree visualization</p> Example <p>paths = ['/root/dir1/file1', '/root/dir1/file2', '/root/dir2'] print(tree_from_string_list(paths)) root \u251c\u2500\u2500 dir1 \u2502   \u251c\u2500\u2500 file1 \u2502   \u2514\u2500\u2500 file2 \u2514\u2500\u2500 dir2</p> Notes <ul> <li>Uses Unicode box-drawing characters</li> <li>Properly handles mixed depth paths</li> <li>Sorts entries for consistent output</li> </ul> <p>Since: 1.0.0</p> Source code in <code>utils/strings.py</code> <pre><code>def tree_from_string_list(paths: List[str]) -&gt; str:\n    \"\"\"Create a tree visualization from a list of path strings.\n\n    Converts a list of path strings into an ASCII tree structure representation,\n    showing hierarchical relationships.\n\n    Args:\n        paths: List of path strings to visualize\n\n    Returns:\n        String containing ASCII tree visualization\n\n    Example:\n        &gt;&gt;&gt; paths = ['/root/dir1/file1', '/root/dir1/file2', '/root/dir2']\n        &gt;&gt;&gt; print(tree_from_string_list(paths))\n        root\n        \u251c\u2500\u2500 dir1\n        \u2502   \u251c\u2500\u2500 file1\n        \u2502   \u2514\u2500\u2500 file2\n        \u2514\u2500\u2500 dir2\n\n    Notes:\n        - Uses Unicode box-drawing characters\n        - Properly handles mixed depth paths\n        - Sorts entries for consistent output\n\n    Since: 1.0.0\n    \"\"\"\n    # Create a dictionary to store the tree structure\n    tree = {}\n\n    # Build the tree\n    for path in paths:\n        parts = path.strip('/').split('/')\n        current = tree\n        for part in parts:\n            current = current.setdefault(part, {})\n\n    # Helper function to build the tree string\n    def build_branch(branch, prefix=''):\n        lines = []\n        for i, (key, value) in enumerate(sorted(branch.items())):\n            is_last = i == len(branch) - 1\n            lines.append(f\"{prefix}{'\u2514\u2500\u2500 ' if is_last else '\u251c\u2500\u2500 '}{key}\")\n            lines.extend(build_branch(value, prefix + ('    ' if is_last else '\u2502   ')))\n        return lines\n\n    # Build and return the tree string\n    return '\\n'.join(build_branch(tree))\n</code></pre>"},{"location":"reference/utils/ui/","title":"ui.py","text":"<p>User interface utilities for NodeWeaver.</p> <p>This module provides utilities for managing Houdini's user interface elements and interactions. It focuses on providing consistent user feedback and handling common UI operations.</p> <p>Functions:</p> Name Description <code>warn_if_manual_mode</code> <p>Display warning if in manual update mode</p>"},{"location":"reference/utils/ui/#utils.ui.warn_if_manual_mode","title":"<code>warn_if_manual_mode(mode='simple', custom='')</code>","text":"<p>Check if Houdini is in manual mode and warn the user if it is.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Warning mode: \"simple\": Basic warning \"errorfull\": Full error message \"errorpartial\": Custom error with manual mode note</p> <code>'simple'</code> <code>custom</code> <code>str</code> <p>Custom message to prepend to warning</p> <code>''</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if warning was displayed (manual mode active)</p> Notes <ul> <li>Checks current update mode setting</li> <li>Formats message appropriately</li> <li>Handles different warning types</li> <li>Returns whether warning was shown</li> </ul> Example <p>if warn_if_manual_mode(\"errorfull\"): ...     return  # Operation cancelled due to manual mode</p> <p>Since: 1.0.0</p> Source code in <code>utils/ui.py</code> <pre><code>def warn_if_manual_mode(mode: str = \"simple\", custom: str = \"\") -&gt; bool:\n    \"\"\"Check if Houdini is in manual mode and warn the user if it is.\n\n    Args:\n        mode: Warning mode:\n            \"simple\": Basic warning\n            \"errorfull\": Full error message\n            \"errorpartial\": Custom error with manual mode note\n        custom: Custom message to prepend to warning\n\n    Returns:\n        True if warning was displayed (manual mode active)\n\n    Notes:\n        - Checks current update mode setting\n        - Formats message appropriately\n        - Handles different warning types\n        - Returns whether warning was shown\n\n    Example:\n        &gt;&gt;&gt; if warn_if_manual_mode(\"errorfull\"):\n        ...     return  # Operation cancelled due to manual mode\n\n    Since: 1.0.0\n    \"\"\"\n    dialogs = {\n        \"simple\": \"Houdini's update mode is set to manual. Some operations may not work as expected. Please switch to auto-update mode by clicking the 'Auto Update' button in the bottom right corner of the Houdini window.\",\n        \"errorfull\": \"This operation failed. It may be because the current update mode is set to manual. Please switch to auto-update mode by clicking the 'Auto Update' button in the bottom right corner of the Houdini window.\",\n        \"errorpartial\": \"It may be because the current update mode is set to manual. Please switch to auto-update mode by clicking the 'Auto Update' button in the bottom right corner of the Houdini window.\",\n    }\n    dialog = dialogs.get(mode, dialogs['simple'])\n    if hou.updateModeSetting() == hou.updateMode.Manual:\n        hou.ui.displayMessage(textwrap.fill(custom + dialog), (\"OK\",))\n        return True\n    return False\n</code></pre>"}]}